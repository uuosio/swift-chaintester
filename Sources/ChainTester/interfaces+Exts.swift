/**
 * Autogenerated by Thrift Compiler (0.15.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: TransactionException, rhs: TransactionException) -> Bool {
  return
    (lhs.exc == rhs.exc)
}

extension TransactionException : CustomStringConvertible {

  public var description : String {
    var desc = "TransactionException("
    desc += "exc=\(String(describing: self.exc))"
    return desc
  }

}

extension TransactionException : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(exc)
  }

}

extension TransactionException : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["exc": 1, ]
  }

  public static var structName: String { return "TransactionException" }

  public static func read(from proto: TProtocol) throws -> TransactionException {
    _ = try proto.readStructBegin()
    var exc: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           exc = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(exc, named: "exc")

    return TransactionException(exc: exc)
  }

}



public func ==(lhs: AssertException, rhs: AssertException) -> Bool {
  return
    (lhs.error_message == rhs.error_message)
}

extension AssertException : CustomStringConvertible {

  public var description : String {
    var desc = "AssertException("
    desc += "error_message=\(String(describing: self.error_message))"
    return desc
  }

}

extension AssertException : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(error_message)
  }

}

extension AssertException : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["error_message": 1, ]
  }

  public static var structName: String { return "AssertException" }

  public static func read(from proto: TProtocol) throws -> AssertException {
    _ = try proto.readStructBegin()
    var error_message: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           error_message = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(error_message, named: "error_message")

    return AssertException(error_message: error_message)
  }

}



public func ==(lhs: Action, rhs: Action) -> Bool {
  return
    (lhs.account == rhs.account) &&
    (lhs.action == rhs.action) &&
    (lhs.permissions == rhs.permissions) &&
    (lhs.arguments == rhs.arguments)
}

extension Action : CustomStringConvertible {

  public var description : String {
    var desc = "Action("
    desc += "account=\(String(describing: self.account)), "
    desc += "action=\(String(describing: self.action)), "
    desc += "permissions=\(String(describing: self.permissions)), "
    desc += "arguments=\(String(describing: self.arguments))"
    return desc
  }

}

extension Action : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(account)
    hasher.combine(action)
    hasher.combine(permissions)
    hasher.combine(arguments)
  }

}

extension Action : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["account": 1, "action": 2, "permissions": 3, "arguments": 4, ]
  }

  public static var structName: String { return "Action" }

  public static func read(from proto: TProtocol) throws -> Action {
    _ = try proto.readStructBegin()
    var account: String!
    var action: String!
    var permissions: String!
    var arguments: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           account = try String.read(from: proto)
        case (2, .string):           action = try String.read(from: proto)
        case (3, .string):           permissions = try String.read(from: proto)
        case (4, .string):           arguments = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(account, named: "account")
    try proto.validateValue(action, named: "action")
    try proto.validateValue(permissions, named: "permissions")
    try proto.validateValue(arguments, named: "arguments")

    return Action(account: account, action: action, permissions: permissions, arguments: arguments)
  }

}



public func ==(lhs: Uint64, rhs: Uint64) -> Bool {
  return
    (lhs.rawValue == rhs.rawValue)
}

extension Uint64 : CustomStringConvertible {

  public var description : String {
    var desc = "Uint64("
    desc += "rawValue=\(String(describing: self.rawValue))"
    return desc
  }

}

extension Uint64 : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }

}

extension Uint64 : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["rawValue": 1, ]
  }

  public static var structName: String { return "Uint64" }

  public static func read(from proto: TProtocol) throws -> Uint64 {
    _ = try proto.readStructBegin()
    var rawValue: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           rawValue = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(rawValue, named: "rawValue")

    return Uint64(rawValue: rawValue)
  }

}



public func ==(lhs: DataBuffer, rhs: DataBuffer) -> Bool {
  return
    (lhs.size == rhs.size) &&
    (lhs.buffer == rhs.buffer)
}

extension DataBuffer : CustomStringConvertible {

  public var description : String {
    var desc = "DataBuffer("
    desc += "size=\(String(describing: self.size)), "
    desc += "buffer=\(String(describing: self.buffer))"
    return desc
  }

}

extension DataBuffer : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(size)
    hasher.combine(buffer)
  }

}

extension DataBuffer : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["size": 1, "buffer": 2, ]
  }

  public static var structName: String { return "DataBuffer" }

  public static func read(from proto: TProtocol) throws -> DataBuffer {
    _ = try proto.readStructBegin()
    var size: Int32!
    var buffer: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             size = try Int32.read(from: proto)
        case (2, .string):           buffer = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(size, named: "size")
    try proto.validateValue(buffer, named: "buffer")

    return DataBuffer(size: size, buffer: buffer)
  }

}



public func ==(lhs: NextPreviousReturn, rhs: NextPreviousReturn) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.primary == rhs.primary)
}

extension NextPreviousReturn : CustomStringConvertible {

  public var description : String {
    var desc = "NextPreviousReturn("
    desc += "iterator=\(String(describing: self.iterator)), "
    desc += "primary=\(String(describing: self.primary))"
    return desc
  }

}

extension NextPreviousReturn : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(primary)
  }

}

extension NextPreviousReturn : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["iterator": 1, "primary": 2, ]
  }

  public static var structName: String { return "NextPreviousReturn" }

  public static func read(from proto: TProtocol) throws -> NextPreviousReturn {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(primary, named: "primary")

    return NextPreviousReturn(iterator: iterator, primary: primary)
  }

}



public func ==(lhs: IteratorPrimaryReturn, rhs: IteratorPrimaryReturn) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.primary == rhs.primary)
}

extension IteratorPrimaryReturn : CustomStringConvertible {

  public var description : String {
    var desc = "IteratorPrimaryReturn("
    desc += "iterator=\(String(describing: self.iterator)), "
    desc += "primary=\(String(describing: self.primary))"
    return desc
  }

}

extension IteratorPrimaryReturn : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(primary)
  }

}

extension IteratorPrimaryReturn : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["iterator": 1, "primary": 2, ]
  }

  public static var structName: String { return "IteratorPrimaryReturn" }

  public static func read(from proto: TProtocol) throws -> IteratorPrimaryReturn {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(primary, named: "primary")

    return IteratorPrimaryReturn(iterator: iterator, primary: primary)
  }

}



public func ==(lhs: FindPrimaryReturn, rhs: FindPrimaryReturn) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.secondary == rhs.secondary)
}

extension FindPrimaryReturn : CustomStringConvertible {

  public var description : String {
    var desc = "FindPrimaryReturn("
    desc += "iterator=\(String(describing: self.iterator)), "
    desc += "secondary=\(String(describing: self.secondary))"
    return desc
  }

}

extension FindPrimaryReturn : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(secondary)
  }

}

extension FindPrimaryReturn : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["iterator": 1, "secondary": 2, ]
  }

  public static var structName: String { return "FindPrimaryReturn" }

  public static func read(from proto: TProtocol) throws -> FindPrimaryReturn {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var secondary: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .string):           secondary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(secondary, named: "secondary")

    return FindPrimaryReturn(iterator: iterator, secondary: secondary)
  }

}



public func ==(lhs: FindSecondaryReturn, rhs: FindSecondaryReturn) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.primary == rhs.primary)
}

extension FindSecondaryReturn : CustomStringConvertible {

  public var description : String {
    var desc = "FindSecondaryReturn("
    desc += "iterator=\(String(describing: self.iterator)), "
    desc += "primary=\(String(describing: self.primary))"
    return desc
  }

}

extension FindSecondaryReturn : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(primary)
  }

}

extension FindSecondaryReturn : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["iterator": 1, "primary": 2, ]
  }

  public static var structName: String { return "FindSecondaryReturn" }

  public static func read(from proto: TProtocol) throws -> FindSecondaryReturn {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(primary, named: "primary")

    return FindSecondaryReturn(iterator: iterator, primary: primary)
  }

}



public func ==(lhs: LowerBoundUpperBoundReturn, rhs: LowerBoundUpperBoundReturn) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.secondary == rhs.secondary) &&
    (lhs.primary == rhs.primary)
}

extension LowerBoundUpperBoundReturn : CustomStringConvertible {

  public var description : String {
    var desc = "LowerBoundUpperBoundReturn("
    desc += "iterator=\(String(describing: self.iterator)), "
    desc += "secondary=\(String(describing: self.secondary)), "
    desc += "primary=\(String(describing: self.primary))"
    return desc
  }

}

extension LowerBoundUpperBoundReturn : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(secondary)
    hasher.combine(primary)
  }

}

extension LowerBoundUpperBoundReturn : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["iterator": 1, "secondary": 2, "primary": 3, ]
  }

  public static var structName: String { return "LowerBoundUpperBoundReturn" }

  public static func read(from proto: TProtocol) throws -> LowerBoundUpperBoundReturn {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var secondary: Data!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .string):           secondary = try Data.read(from: proto)
        case (3, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(secondary, named: "secondary")
    try proto.validateValue(primary, named: "primary")

    return LowerBoundUpperBoundReturn(iterator: iterator, secondary: secondary, primary: primary)
  }

}



public func ==(lhs: GetResourceLimitsReturn, rhs: GetResourceLimitsReturn) -> Bool {
  return
    (lhs.ram_bytes == rhs.ram_bytes) &&
    (lhs.net_weight == rhs.net_weight) &&
    (lhs.cpu_weight == rhs.cpu_weight)
}

extension GetResourceLimitsReturn : CustomStringConvertible {

  public var description : String {
    var desc = "GetResourceLimitsReturn("
    desc += "ram_bytes=\(String(describing: self.ram_bytes)), "
    desc += "net_weight=\(String(describing: self.net_weight)), "
    desc += "cpu_weight=\(String(describing: self.cpu_weight))"
    return desc
  }

}

extension GetResourceLimitsReturn : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(ram_bytes)
    hasher.combine(net_weight)
    hasher.combine(cpu_weight)
  }

}

extension GetResourceLimitsReturn : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["ram_bytes": 1, "net_weight": 2, "cpu_weight": 3, ]
  }

  public static var structName: String { return "GetResourceLimitsReturn" }

  public static func read(from proto: TProtocol) throws -> GetResourceLimitsReturn {
    _ = try proto.readStructBegin()
    var ram_bytes: Int64!
    var net_weight: Int64!
    var cpu_weight: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             ram_bytes = try Int64.read(from: proto)
        case (2, .i64):             net_weight = try Int64.read(from: proto)
        case (3, .i64):             cpu_weight = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(ram_bytes, named: "ram_bytes")
    try proto.validateValue(net_weight, named: "net_weight")
    try proto.validateValue(cpu_weight, named: "cpu_weight")

    return GetResourceLimitsReturn(ram_bytes: ram_bytes, net_weight: net_weight, cpu_weight: cpu_weight)
  }

}



fileprivate final class IPCChainTester_init_vm_api_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: IPCChainTester_init_vm_api_args, rhs: IPCChainTester_init_vm_api_args) -> Bool {
  return true
}

extension IPCChainTester_init_vm_api_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension IPCChainTester_init_vm_api_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "IPCChainTester_init_vm_api_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_init_vm_api_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_init_vm_api_args()
  }

}



fileprivate final class IPCChainTester_init_apply_request_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: IPCChainTester_init_apply_request_args, rhs: IPCChainTester_init_apply_request_args) -> Bool {
  return true
}

extension IPCChainTester_init_apply_request_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension IPCChainTester_init_apply_request_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "IPCChainTester_init_apply_request_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_init_apply_request_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_init_apply_request_args()
  }

}



fileprivate final class IPCChainTester_enable_debug_contract_args {

  fileprivate var id: Int32

  fileprivate var contract: String

  fileprivate var enable: Bool


  fileprivate init(id: Int32, contract: String, enable: Bool) {
    self.id = id
    self.contract = contract
    self.enable = enable
  }

}

fileprivate func ==(lhs: IPCChainTester_enable_debug_contract_args, rhs: IPCChainTester_enable_debug_contract_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.contract == rhs.contract) &&
    (lhs.enable == rhs.enable)
}

extension IPCChainTester_enable_debug_contract_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(contract)
    hasher.combine(enable)
  }

}

extension IPCChainTester_enable_debug_contract_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "contract": 2, "enable": 3, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_enable_debug_contract_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_enable_debug_contract_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var contract: String!
    var enable: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           contract = try String.read(from: proto)
        case (3, .bool):            enable = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(contract, named: "contract")
    try proto.validateValue(enable, named: "enable")

    return IPCChainTester_enable_debug_contract_args(id: id, contract: contract, enable: enable)
  }

}



fileprivate final class IPCChainTester_enable_debug_contract_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: IPCChainTester_enable_debug_contract_result, rhs: IPCChainTester_enable_debug_contract_result) -> Bool {
  return true
}

extension IPCChainTester_enable_debug_contract_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension IPCChainTester_enable_debug_contract_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "IPCChainTester_enable_debug_contract_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_enable_debug_contract_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_enable_debug_contract_result()
  }

}



fileprivate final class IPCChainTester_is_debug_contract_enabled_args {

  fileprivate var id: Int32

  fileprivate var contract: String


  fileprivate init(id: Int32, contract: String) {
    self.id = id
    self.contract = contract
  }

}

fileprivate func ==(lhs: IPCChainTester_is_debug_contract_enabled_args, rhs: IPCChainTester_is_debug_contract_enabled_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.contract == rhs.contract)
}

extension IPCChainTester_is_debug_contract_enabled_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(contract)
  }

}

extension IPCChainTester_is_debug_contract_enabled_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "contract": 2, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_is_debug_contract_enabled_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_is_debug_contract_enabled_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var contract: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           contract = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(contract, named: "contract")

    return IPCChainTester_is_debug_contract_enabled_args(id: id, contract: contract)
  }

}



fileprivate final class IPCChainTester_is_debug_contract_enabled_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_is_debug_contract_enabled_result, rhs: IPCChainTester_is_debug_contract_enabled_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_is_debug_contract_enabled_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_is_debug_contract_enabled_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_is_debug_contract_enabled_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_is_debug_contract_enabled_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_is_debug_contract_enabled_result(success: success)
  }

}



fileprivate final class IPCChainTester_pack_abi_args {

  fileprivate var abi: String


  fileprivate init(abi: String) {
    self.abi = abi
  }

}

fileprivate func ==(lhs: IPCChainTester_pack_abi_args, rhs: IPCChainTester_pack_abi_args) -> Bool {
  return
    (lhs.abi == rhs.abi)
}

extension IPCChainTester_pack_abi_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(abi)
  }

}

extension IPCChainTester_pack_abi_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["abi": 1, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_pack_abi_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_pack_abi_args {
    _ = try proto.readStructBegin()
    var abi: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           abi = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(abi, named: "abi")

    return IPCChainTester_pack_abi_args(abi: abi)
  }

}



fileprivate final class IPCChainTester_pack_abi_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_pack_abi_result, rhs: IPCChainTester_pack_abi_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_pack_abi_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_pack_abi_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_pack_abi_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_pack_abi_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_pack_abi_result(success: success)
  }

}



fileprivate final class IPCChainTester_pack_action_args_args {

  fileprivate var id: Int32

  fileprivate var contract: String

  fileprivate var action: String

  fileprivate var action_args: String


  fileprivate init(id: Int32, contract: String, action: String, action_args: String) {
    self.id = id
    self.contract = contract
    self.action = action
    self.action_args = action_args
  }

}

fileprivate func ==(lhs: IPCChainTester_pack_action_args_args, rhs: IPCChainTester_pack_action_args_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.contract == rhs.contract) &&
    (lhs.action == rhs.action) &&
    (lhs.action_args == rhs.action_args)
}

extension IPCChainTester_pack_action_args_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(contract)
    hasher.combine(action)
    hasher.combine(action_args)
  }

}

extension IPCChainTester_pack_action_args_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "contract": 2, "action": 3, "action_args": 4, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_pack_action_args_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_pack_action_args_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var contract: String!
    var action: String!
    var action_args: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           contract = try String.read(from: proto)
        case (3, .string):           action = try String.read(from: proto)
        case (4, .string):           action_args = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(contract, named: "contract")
    try proto.validateValue(action, named: "action")
    try proto.validateValue(action_args, named: "action_args")

    return IPCChainTester_pack_action_args_args(id: id, contract: contract, action: action, action_args: action_args)
  }

}



fileprivate final class IPCChainTester_pack_action_args_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_pack_action_args_result, rhs: IPCChainTester_pack_action_args_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_pack_action_args_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_pack_action_args_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_pack_action_args_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_pack_action_args_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_pack_action_args_result(success: success)
  }

}



fileprivate final class IPCChainTester_unpack_action_args_args {

  fileprivate var id: Int32

  fileprivate var contract: String

  fileprivate var action: String

  fileprivate var raw_args: Data


  fileprivate init(id: Int32, contract: String, action: String, raw_args: Data) {
    self.id = id
    self.contract = contract
    self.action = action
    self.raw_args = raw_args
  }

}

fileprivate func ==(lhs: IPCChainTester_unpack_action_args_args, rhs: IPCChainTester_unpack_action_args_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.contract == rhs.contract) &&
    (lhs.action == rhs.action) &&
    (lhs.raw_args == rhs.raw_args)
}

extension IPCChainTester_unpack_action_args_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(contract)
    hasher.combine(action)
    hasher.combine(raw_args)
  }

}

extension IPCChainTester_unpack_action_args_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "contract": 2, "action": 3, "raw_args": 4, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_unpack_action_args_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_unpack_action_args_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var contract: String!
    var action: String!
    var raw_args: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           contract = try String.read(from: proto)
        case (3, .string):           action = try String.read(from: proto)
        case (4, .string):           raw_args = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(contract, named: "contract")
    try proto.validateValue(action, named: "action")
    try proto.validateValue(raw_args, named: "raw_args")

    return IPCChainTester_unpack_action_args_args(id: id, contract: contract, action: action, raw_args: raw_args)
  }

}



fileprivate final class IPCChainTester_unpack_action_args_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_unpack_action_args_result, rhs: IPCChainTester_unpack_action_args_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_unpack_action_args_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_unpack_action_args_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_unpack_action_args_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_unpack_action_args_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_unpack_action_args_result(success: success)
  }

}



fileprivate final class IPCChainTester_new_chain_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: IPCChainTester_new_chain_args, rhs: IPCChainTester_new_chain_args) -> Bool {
  return true
}

extension IPCChainTester_new_chain_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension IPCChainTester_new_chain_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "IPCChainTester_new_chain_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_new_chain_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_new_chain_args()
  }

}



fileprivate final class IPCChainTester_new_chain_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_new_chain_result, rhs: IPCChainTester_new_chain_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_new_chain_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_new_chain_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_new_chain_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_new_chain_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_new_chain_result(success: success)
  }

}



fileprivate final class IPCChainTester_free_chain_args {

  fileprivate var id: Int32


  fileprivate init(id: Int32) {
    self.id = id
  }

}

fileprivate func ==(lhs: IPCChainTester_free_chain_args, rhs: IPCChainTester_free_chain_args) -> Bool {
  return
    (lhs.id == rhs.id)
}

extension IPCChainTester_free_chain_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
  }

}

extension IPCChainTester_free_chain_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_free_chain_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_free_chain_args {
    _ = try proto.readStructBegin()
    var id: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")

    return IPCChainTester_free_chain_args(id: id)
  }

}



fileprivate final class IPCChainTester_free_chain_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_free_chain_result, rhs: IPCChainTester_free_chain_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_free_chain_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_free_chain_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_free_chain_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_free_chain_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_free_chain_result(success: success)
  }

}



fileprivate final class IPCChainTester_get_info_args {

  fileprivate var id: Int32


  fileprivate init(id: Int32) {
    self.id = id
  }

}

fileprivate func ==(lhs: IPCChainTester_get_info_args, rhs: IPCChainTester_get_info_args) -> Bool {
  return
    (lhs.id == rhs.id)
}

extension IPCChainTester_get_info_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
  }

}

extension IPCChainTester_get_info_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_get_info_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_get_info_args {
    _ = try proto.readStructBegin()
    var id: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")

    return IPCChainTester_get_info_args(id: id)
  }

}



fileprivate final class IPCChainTester_get_info_result {

  fileprivate var success: String?


  fileprivate init() { }
  fileprivate init(success: String?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_get_info_result, rhs: IPCChainTester_get_info_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_get_info_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_get_info_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_get_info_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_get_info_result {
    _ = try proto.readStructBegin()
    var success: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_get_info_result(success: success)
  }

}



fileprivate final class IPCChainTester_create_key_args {

  fileprivate var key_type: String


  fileprivate init(key_type: String) {
    self.key_type = key_type
  }

}

fileprivate func ==(lhs: IPCChainTester_create_key_args, rhs: IPCChainTester_create_key_args) -> Bool {
  return
    (lhs.key_type == rhs.key_type)
}

extension IPCChainTester_create_key_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(key_type)
  }

}

extension IPCChainTester_create_key_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["key_type": 1, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_create_key_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_create_key_args {
    _ = try proto.readStructBegin()
    var key_type: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           key_type = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(key_type, named: "key_type")

    return IPCChainTester_create_key_args(key_type: key_type)
  }

}



fileprivate final class IPCChainTester_create_key_result {

  fileprivate var success: String?


  fileprivate init() { }
  fileprivate init(success: String?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_create_key_result, rhs: IPCChainTester_create_key_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_create_key_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_create_key_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_create_key_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_create_key_result {
    _ = try proto.readStructBegin()
    var success: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_create_key_result(success: success)
  }

}



fileprivate final class IPCChainTester_get_account_args {

  fileprivate var id: Int32

  fileprivate var account: String


  fileprivate init(id: Int32, account: String) {
    self.id = id
    self.account = account
  }

}

fileprivate func ==(lhs: IPCChainTester_get_account_args, rhs: IPCChainTester_get_account_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.account == rhs.account)
}

extension IPCChainTester_get_account_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(account)
  }

}

extension IPCChainTester_get_account_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "account": 2, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_get_account_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_get_account_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var account: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           account = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(account, named: "account")

    return IPCChainTester_get_account_args(id: id, account: account)
  }

}



fileprivate final class IPCChainTester_get_account_result {

  fileprivate var success: String?


  fileprivate init() { }
  fileprivate init(success: String?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_get_account_result, rhs: IPCChainTester_get_account_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_get_account_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_get_account_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_get_account_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_get_account_result {
    _ = try proto.readStructBegin()
    var success: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_get_account_result(success: success)
  }

}



fileprivate final class IPCChainTester_create_account_args {

  fileprivate var id: Int32

  fileprivate var creator: String

  fileprivate var account: String

  fileprivate var owner_key: String

  fileprivate var active_key: String

  fileprivate var ram_bytes: Int64

  fileprivate var stake_net: Int64

  fileprivate var stake_cpu: Int64


  fileprivate init(id: Int32, creator: String, account: String, owner_key: String, active_key: String, ram_bytes: Int64, stake_net: Int64, stake_cpu: Int64) {
    self.id = id
    self.creator = creator
    self.account = account
    self.owner_key = owner_key
    self.active_key = active_key
    self.ram_bytes = ram_bytes
    self.stake_net = stake_net
    self.stake_cpu = stake_cpu
  }

}

fileprivate func ==(lhs: IPCChainTester_create_account_args, rhs: IPCChainTester_create_account_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.creator == rhs.creator) &&
    (lhs.account == rhs.account) &&
    (lhs.owner_key == rhs.owner_key) &&
    (lhs.active_key == rhs.active_key) &&
    (lhs.ram_bytes == rhs.ram_bytes) &&
    (lhs.stake_net == rhs.stake_net) &&
    (lhs.stake_cpu == rhs.stake_cpu)
}

extension IPCChainTester_create_account_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(creator)
    hasher.combine(account)
    hasher.combine(owner_key)
    hasher.combine(active_key)
    hasher.combine(ram_bytes)
    hasher.combine(stake_net)
    hasher.combine(stake_cpu)
  }

}

extension IPCChainTester_create_account_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "creator": 2, "account": 3, "owner_key": 4, "active_key": 5, "ram_bytes": 6, "stake_net": 7, "stake_cpu": 8, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_create_account_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_create_account_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var creator: String!
    var account: String!
    var owner_key: String!
    var active_key: String!
    var ram_bytes: Int64!
    var stake_net: Int64!
    var stake_cpu: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           creator = try String.read(from: proto)
        case (3, .string):           account = try String.read(from: proto)
        case (4, .string):           owner_key = try String.read(from: proto)
        case (5, .string):           active_key = try String.read(from: proto)
        case (6, .i64):             ram_bytes = try Int64.read(from: proto)
        case (7, .i64):             stake_net = try Int64.read(from: proto)
        case (8, .i64):             stake_cpu = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(creator, named: "creator")
    try proto.validateValue(account, named: "account")
    try proto.validateValue(owner_key, named: "owner_key")
    try proto.validateValue(active_key, named: "active_key")
    try proto.validateValue(ram_bytes, named: "ram_bytes")
    try proto.validateValue(stake_net, named: "stake_net")
    try proto.validateValue(stake_cpu, named: "stake_cpu")

    return IPCChainTester_create_account_args(id: id, creator: creator, account: account, owner_key: owner_key, active_key: active_key, ram_bytes: ram_bytes, stake_net: stake_net, stake_cpu: stake_cpu)
  }

}



fileprivate final class IPCChainTester_create_account_result {

  fileprivate var success: String?


  fileprivate init() { }
  fileprivate init(success: String?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_create_account_result, rhs: IPCChainTester_create_account_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_create_account_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_create_account_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_create_account_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_create_account_result {
    _ = try proto.readStructBegin()
    var success: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_create_account_result(success: success)
  }

}



fileprivate final class IPCChainTester_import_key_args {

  fileprivate var id: Int32

  fileprivate var pub_key: String

  fileprivate var priv_key: String


  fileprivate init(id: Int32, pub_key: String, priv_key: String) {
    self.id = id
    self.pub_key = pub_key
    self.priv_key = priv_key
  }

}

fileprivate func ==(lhs: IPCChainTester_import_key_args, rhs: IPCChainTester_import_key_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.pub_key == rhs.pub_key) &&
    (lhs.priv_key == rhs.priv_key)
}

extension IPCChainTester_import_key_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(pub_key)
    hasher.combine(priv_key)
  }

}

extension IPCChainTester_import_key_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "pub_key": 2, "priv_key": 3, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_import_key_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_import_key_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var pub_key: String!
    var priv_key: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           pub_key = try String.read(from: proto)
        case (3, .string):           priv_key = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(pub_key, named: "pub_key")
    try proto.validateValue(priv_key, named: "priv_key")

    return IPCChainTester_import_key_args(id: id, pub_key: pub_key, priv_key: priv_key)
  }

}



fileprivate final class IPCChainTester_import_key_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_import_key_result, rhs: IPCChainTester_import_key_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_import_key_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_import_key_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_import_key_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_import_key_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_import_key_result(success: success)
  }

}



fileprivate final class IPCChainTester_get_required_keys_args {

  fileprivate var id: Int32

  fileprivate var transaction: String

  fileprivate var available_keys: TList<String>


  fileprivate init(id: Int32, transaction: String, available_keys: TList<String>) {
    self.id = id
    self.transaction = transaction
    self.available_keys = available_keys
  }

}

fileprivate func ==(lhs: IPCChainTester_get_required_keys_args, rhs: IPCChainTester_get_required_keys_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.transaction == rhs.transaction) &&
    (lhs.available_keys == rhs.available_keys)
}

extension IPCChainTester_get_required_keys_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(transaction)
    hasher.combine(available_keys)
  }

}

extension IPCChainTester_get_required_keys_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "transaction": 2, "available_keys": 3, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_get_required_keys_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_get_required_keys_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var transaction: String!
    var available_keys: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           transaction = try String.read(from: proto)
        case (3, .list):            available_keys = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(transaction, named: "transaction")
    try proto.validateValue(available_keys, named: "available_keys")

    return IPCChainTester_get_required_keys_args(id: id, transaction: transaction, available_keys: available_keys)
  }

}



fileprivate final class IPCChainTester_get_required_keys_result {

  fileprivate var success: String?


  fileprivate init() { }
  fileprivate init(success: String?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_get_required_keys_result, rhs: IPCChainTester_get_required_keys_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_get_required_keys_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_get_required_keys_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_get_required_keys_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_get_required_keys_result {
    _ = try proto.readStructBegin()
    var success: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_get_required_keys_result(success: success)
  }

}



fileprivate final class IPCChainTester_produce_block_args {

  fileprivate var id: Int32

  fileprivate var next_block_skip_seconds: Int64


  fileprivate init(id: Int32, next_block_skip_seconds: Int64) {
    self.id = id
    self.next_block_skip_seconds = next_block_skip_seconds
  }

}

fileprivate func ==(lhs: IPCChainTester_produce_block_args, rhs: IPCChainTester_produce_block_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.next_block_skip_seconds == rhs.next_block_skip_seconds)
}

extension IPCChainTester_produce_block_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(next_block_skip_seconds)
  }

}

extension IPCChainTester_produce_block_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "next_block_skip_seconds": 2, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_produce_block_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_produce_block_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var next_block_skip_seconds: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .i64):             next_block_skip_seconds = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(next_block_skip_seconds, named: "next_block_skip_seconds")

    return IPCChainTester_produce_block_args(id: id, next_block_skip_seconds: next_block_skip_seconds)
  }

}



fileprivate final class IPCChainTester_produce_block_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: IPCChainTester_produce_block_result, rhs: IPCChainTester_produce_block_result) -> Bool {
  return true
}

extension IPCChainTester_produce_block_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension IPCChainTester_produce_block_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "IPCChainTester_produce_block_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_produce_block_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_produce_block_result()
  }

}



fileprivate final class IPCChainTester_push_action_args {

  fileprivate var id: Int32

  fileprivate var account: String

  fileprivate var action: String

  fileprivate var arguments: String

  fileprivate var permissions: String


  fileprivate init(id: Int32, account: String, action: String, arguments: String, permissions: String) {
    self.id = id
    self.account = account
    self.action = action
    self.arguments = arguments
    self.permissions = permissions
  }

}

fileprivate func ==(lhs: IPCChainTester_push_action_args, rhs: IPCChainTester_push_action_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.account == rhs.account) &&
    (lhs.action == rhs.action) &&
    (lhs.arguments == rhs.arguments) &&
    (lhs.permissions == rhs.permissions)
}

extension IPCChainTester_push_action_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(account)
    hasher.combine(action)
    hasher.combine(arguments)
    hasher.combine(permissions)
  }

}

extension IPCChainTester_push_action_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "account": 2, "action": 3, "arguments": 4, "permissions": 5, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_push_action_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_push_action_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var account: String!
    var action: String!
    var arguments: String!
    var permissions: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           account = try String.read(from: proto)
        case (3, .string):           action = try String.read(from: proto)
        case (4, .string):           arguments = try String.read(from: proto)
        case (5, .string):           permissions = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(account, named: "account")
    try proto.validateValue(action, named: "action")
    try proto.validateValue(arguments, named: "arguments")
    try proto.validateValue(permissions, named: "permissions")

    return IPCChainTester_push_action_args(id: id, account: account, action: action, arguments: arguments, permissions: permissions)
  }

}



fileprivate final class IPCChainTester_push_action_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_push_action_result, rhs: IPCChainTester_push_action_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_push_action_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_push_action_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_push_action_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_push_action_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_push_action_result(success: success)
  }

}



fileprivate final class IPCChainTester_push_actions_args {

  fileprivate var id: Int32

  fileprivate var actions: TList<Action>


  fileprivate init(id: Int32, actions: TList<Action>) {
    self.id = id
    self.actions = actions
  }

}

fileprivate func ==(lhs: IPCChainTester_push_actions_args, rhs: IPCChainTester_push_actions_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.actions == rhs.actions)
}

extension IPCChainTester_push_actions_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(actions)
  }

}

extension IPCChainTester_push_actions_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "actions": 2, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_push_actions_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_push_actions_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var actions: TList<Action>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .list):            actions = try TList<Action>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(actions, named: "actions")

    return IPCChainTester_push_actions_args(id: id, actions: actions)
  }

}



fileprivate final class IPCChainTester_push_actions_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_push_actions_result, rhs: IPCChainTester_push_actions_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_push_actions_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_push_actions_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_push_actions_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_push_actions_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_push_actions_result(success: success)
  }

}



fileprivate final class IPCChainTester_get_table_rows_args {

  fileprivate var id: Int32

  fileprivate var json: Bool

  fileprivate var code: String

  fileprivate var scope: String

  fileprivate var table: String

  fileprivate var lower_bound: String

  fileprivate var upper_bound: String

  fileprivate var limit: Int64

  fileprivate var key_type: String

  fileprivate var index_position: String

  fileprivate var reverse: Bool

  fileprivate var show_payer: Bool


  fileprivate init(id: Int32, json: Bool, code: String, scope: String, table: String, lower_bound: String, upper_bound: String, limit: Int64, key_type: String, index_position: String, reverse: Bool, show_payer: Bool) {
    self.id = id
    self.json = json
    self.code = code
    self.scope = scope
    self.table = table
    self.lower_bound = lower_bound
    self.upper_bound = upper_bound
    self.limit = limit
    self.key_type = key_type
    self.index_position = index_position
    self.reverse = reverse
    self.show_payer = show_payer
  }

}

fileprivate func ==(lhs: IPCChainTester_get_table_rows_args, rhs: IPCChainTester_get_table_rows_args) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.json == rhs.json) &&
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.lower_bound == rhs.lower_bound) &&
    (lhs.upper_bound == rhs.upper_bound) &&
    (lhs.limit == rhs.limit) &&
    (lhs.key_type == rhs.key_type) &&
    (lhs.index_position == rhs.index_position) &&
    (lhs.reverse == rhs.reverse) &&
    (lhs.show_payer == rhs.show_payer)
}

extension IPCChainTester_get_table_rows_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(json)
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(lower_bound)
    hasher.combine(upper_bound)
    hasher.combine(limit)
    hasher.combine(key_type)
    hasher.combine(index_position)
    hasher.combine(reverse)
    hasher.combine(show_payer)
  }

}

extension IPCChainTester_get_table_rows_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, "json": 2, "code": 3, "scope": 4, "table": 5, "lower_bound": 6, "upper_bound": 7, "limit": 8, "key_type": 9, "index_position": 10, "reverse": 11, "show_payer": 12, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_get_table_rows_args" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_get_table_rows_args {
    _ = try proto.readStructBegin()
    var id: Int32!
    var json: Bool!
    var code: String!
    var scope: String!
    var table: String!
    var lower_bound: String!
    var upper_bound: String!
    var limit: Int64!
    var key_type: String!
    var index_position: String!
    var reverse: Bool!
    var show_payer: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .bool):            json = try Bool.read(from: proto)
        case (3, .string):           code = try String.read(from: proto)
        case (4, .string):           scope = try String.read(from: proto)
        case (5, .string):           table = try String.read(from: proto)
        case (6, .string):           lower_bound = try String.read(from: proto)
        case (7, .string):           upper_bound = try String.read(from: proto)
        case (8, .i64):             limit = try Int64.read(from: proto)
        case (9, .string):           key_type = try String.read(from: proto)
        case (10, .string):           index_position = try String.read(from: proto)
        case (11, .bool):            reverse = try Bool.read(from: proto)
        case (12, .bool):            show_payer = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(json, named: "json")
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(lower_bound, named: "lower_bound")
    try proto.validateValue(upper_bound, named: "upper_bound")
    try proto.validateValue(limit, named: "limit")
    try proto.validateValue(key_type, named: "key_type")
    try proto.validateValue(index_position, named: "index_position")
    try proto.validateValue(reverse, named: "reverse")
    try proto.validateValue(show_payer, named: "show_payer")

    return IPCChainTester_get_table_rows_args(id: id, json: json, code: code, scope: scope, table: table, lower_bound: lower_bound, upper_bound: upper_bound, limit: limit, key_type: key_type, index_position: index_position, reverse: reverse, show_payer: show_payer)
  }

}



fileprivate final class IPCChainTester_get_table_rows_result {

  fileprivate var success: String?


  fileprivate init() { }
  fileprivate init(success: String?) {
    self.success = success
  }

}

fileprivate func ==(lhs: IPCChainTester_get_table_rows_result, rhs: IPCChainTester_get_table_rows_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension IPCChainTester_get_table_rows_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension IPCChainTester_get_table_rows_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "IPCChainTester_get_table_rows_result" }

  fileprivate static func read(from proto: TProtocol) throws -> IPCChainTester_get_table_rows_result {
    _ = try proto.readStructBegin()
    var success: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return IPCChainTester_get_table_rows_result(success: success)
  }

}



extension IPCChainTesterClient : IPCChainTester {

  private func send_init_vm_api() throws {
    try outProtocol.writeMessageBegin(name: "init_vm_api", type: .oneway, sequenceID: 0)
    let args = IPCChainTester_init_vm_api_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  public func init_vm_api() throws {
    try send_init_vm_api()
    try outProtocol.transport.flush()
  }

  private func send_init_apply_request() throws {
    try outProtocol.writeMessageBegin(name: "init_apply_request", type: .oneway, sequenceID: 0)
    let args = IPCChainTester_init_apply_request_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  public func init_apply_request() throws {
    try send_init_apply_request()
    try outProtocol.transport.flush()
  }

  private func send_enable_debug_contract(id: Int32, contract: String, enable: Bool) throws {
    try outProtocol.writeMessageBegin(name: "enable_debug_contract", type: .call, sequenceID: 0)
    let args = IPCChainTester_enable_debug_contract_args(id: id, contract: contract, enable: enable)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_enable_debug_contract() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try IPCChainTester_enable_debug_contract_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func enable_debug_contract(id: Int32, contract: String, enable: Bool) throws {
    try send_enable_debug_contract(id: id, contract: contract, enable: enable)
    try outProtocol.transport.flush()
    try recv_enable_debug_contract()
  }

  private func send_is_debug_contract_enabled(id: Int32, contract: String) throws {
    try outProtocol.writeMessageBegin(name: "is_debug_contract_enabled", type: .call, sequenceID: 0)
    let args = IPCChainTester_is_debug_contract_enabled_args(id: id, contract: contract)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_is_debug_contract_enabled() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_is_debug_contract_enabled_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "is_debug_contract_enabled"))
  }

  public func is_debug_contract_enabled(id: Int32, contract: String) throws -> Bool {
    try send_is_debug_contract_enabled(id: id, contract: contract)
    try outProtocol.transport.flush()
    return try recv_is_debug_contract_enabled()
  }

  private func send_pack_abi(abi: String) throws {
    try outProtocol.writeMessageBegin(name: "pack_abi", type: .call, sequenceID: 0)
    let args = IPCChainTester_pack_abi_args(abi: abi)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_pack_abi() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_pack_abi_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "pack_abi"))
  }

  public func pack_abi(abi: String) throws -> Data {
    try send_pack_abi(abi: abi)
    try outProtocol.transport.flush()
    return try recv_pack_abi()
  }

  private func send_pack_action_args(id: Int32, contract: String, action: String, action_args: String) throws {
    try outProtocol.writeMessageBegin(name: "pack_action_args", type: .call, sequenceID: 0)
    let args = IPCChainTester_pack_action_args_args(id: id, contract: contract, action: action, action_args: action_args)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_pack_action_args() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_pack_action_args_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "pack_action_args"))
  }

  public func pack_action_args(id: Int32, contract: String, action: String, action_args: String) throws -> Data {
    try send_pack_action_args(id: id, contract: contract, action: action, action_args: action_args)
    try outProtocol.transport.flush()
    return try recv_pack_action_args()
  }

  private func send_unpack_action_args(id: Int32, contract: String, action: String, raw_args: Data) throws {
    try outProtocol.writeMessageBegin(name: "unpack_action_args", type: .call, sequenceID: 0)
    let args = IPCChainTester_unpack_action_args_args(id: id, contract: contract, action: action, raw_args: raw_args)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unpack_action_args() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_unpack_action_args_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "unpack_action_args"))
  }

  public func unpack_action_args(id: Int32, contract: String, action: String, raw_args: Data) throws -> Data {
    try send_unpack_action_args(id: id, contract: contract, action: action, raw_args: raw_args)
    try outProtocol.transport.flush()
    return try recv_unpack_action_args()
  }

  private func send_new_chain() throws {
    try outProtocol.writeMessageBegin(name: "new_chain", type: .call, sequenceID: 0)
    let args = IPCChainTester_new_chain_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_new_chain() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_new_chain_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "new_chain"))
  }

  public func new_chain() throws -> Int32 {
    try send_new_chain()
    try outProtocol.transport.flush()
    return try recv_new_chain()
  }

  private func send_free_chain(id: Int32) throws {
    try outProtocol.writeMessageBegin(name: "free_chain", type: .call, sequenceID: 0)
    let args = IPCChainTester_free_chain_args(id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_free_chain() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_free_chain_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "free_chain"))
  }

  public func free_chain(id: Int32) throws -> Int32 {
    try send_free_chain(id: id)
    try outProtocol.transport.flush()
    return try recv_free_chain()
  }

  private func send_get_info(id: Int32) throws {
    try outProtocol.writeMessageBegin(name: "get_info", type: .call, sequenceID: 0)
    let args = IPCChainTester_get_info_args(id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_info() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_get_info_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_info"))
  }

  public func get_info(id: Int32) throws -> String {
    try send_get_info(id: id)
    try outProtocol.transport.flush()
    return try recv_get_info()
  }

  private func send_create_key(key_type: String) throws {
    try outProtocol.writeMessageBegin(name: "create_key", type: .call, sequenceID: 0)
    let args = IPCChainTester_create_key_args(key_type: key_type)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_create_key() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_create_key_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "create_key"))
  }

  public func create_key(key_type: String) throws -> String {
    try send_create_key(key_type: key_type)
    try outProtocol.transport.flush()
    return try recv_create_key()
  }

  private func send_get_account(id: Int32, account: String) throws {
    try outProtocol.writeMessageBegin(name: "get_account", type: .call, sequenceID: 0)
    let args = IPCChainTester_get_account_args(id: id, account: account)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_account() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_get_account_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_account"))
  }

  public func get_account(id: Int32, account: String) throws -> String {
    try send_get_account(id: id, account: account)
    try outProtocol.transport.flush()
    return try recv_get_account()
  }

  private func send_create_account(id: Int32, creator: String, account: String, owner_key: String, active_key: String, ram_bytes: Int64, stake_net: Int64, stake_cpu: Int64) throws {
    try outProtocol.writeMessageBegin(name: "create_account", type: .call, sequenceID: 0)
    let args = IPCChainTester_create_account_args(id: id, creator: creator, account: account, owner_key: owner_key, active_key: active_key, ram_bytes: ram_bytes, stake_net: stake_net, stake_cpu: stake_cpu)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_create_account() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_create_account_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "create_account"))
  }

  public func create_account(id: Int32, creator: String, account: String, owner_key: String, active_key: String, ram_bytes: Int64, stake_net: Int64, stake_cpu: Int64) throws -> String {
    try send_create_account(id: id, creator: creator, account: account, owner_key: owner_key, active_key: active_key, ram_bytes: ram_bytes, stake_net: stake_net, stake_cpu: stake_cpu)
    try outProtocol.transport.flush()
    return try recv_create_account()
  }

  private func send_import_key(id: Int32, pub_key: String, priv_key: String) throws {
    try outProtocol.writeMessageBegin(name: "import_key", type: .call, sequenceID: 0)
    let args = IPCChainTester_import_key_args(id: id, pub_key: pub_key, priv_key: priv_key)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_import_key() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_import_key_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "import_key"))
  }

  public func import_key(id: Int32, pub_key: String, priv_key: String) throws -> Bool {
    try send_import_key(id: id, pub_key: pub_key, priv_key: priv_key)
    try outProtocol.transport.flush()
    return try recv_import_key()
  }

  private func send_get_required_keys(id: Int32, transaction: String, available_keys: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "get_required_keys", type: .call, sequenceID: 0)
    let args = IPCChainTester_get_required_keys_args(id: id, transaction: transaction, available_keys: available_keys)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_required_keys() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_get_required_keys_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_required_keys"))
  }

  public func get_required_keys(id: Int32, transaction: String, available_keys: TList<String>) throws -> String {
    try send_get_required_keys(id: id, transaction: transaction, available_keys: available_keys)
    try outProtocol.transport.flush()
    return try recv_get_required_keys()
  }

  private func send_produce_block(id: Int32, next_block_skip_seconds: Int64) throws {
    try outProtocol.writeMessageBegin(name: "produce_block", type: .call, sequenceID: 0)
    let args = IPCChainTester_produce_block_args(id: id, next_block_skip_seconds: next_block_skip_seconds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_produce_block() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try IPCChainTester_produce_block_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func produce_block(id: Int32, next_block_skip_seconds: Int64) throws {
    try send_produce_block(id: id, next_block_skip_seconds: next_block_skip_seconds)
    try outProtocol.transport.flush()
    try recv_produce_block()
  }

  public func send_push_action(id: Int32, account: String, action: String, arguments: String, permissions: String) throws {
    try outProtocol.writeMessageBegin(name: "push_action", type: .call, sequenceID: 0)
    let args = IPCChainTester_push_action_args(id: id, account: account, action: action, arguments: arguments, permissions: permissions)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  public func recv_push_action() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_push_action_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "push_action"))
  }

  public func push_action(id: Int32, account: String, action: String, arguments: String, permissions: String) throws -> Data {
    try send_push_action(id: id, account: account, action: action, arguments: arguments, permissions: permissions)
    try outProtocol.transport.flush()
    return try recv_push_action()
  }

  private func send_push_actions(id: Int32, actions: TList<Action>) throws {
    try outProtocol.writeMessageBegin(name: "push_actions", type: .call, sequenceID: 0)
    let args = IPCChainTester_push_actions_args(id: id, actions: actions)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_push_actions() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_push_actions_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "push_actions"))
  }

  public func push_actions(id: Int32, actions: TList<Action>) throws -> Data {
    try send_push_actions(id: id, actions: actions)
    try outProtocol.transport.flush()
    return try recv_push_actions()
  }

  private func send_get_table_rows(id: Int32, json: Bool, code: String, scope: String, table: String, lower_bound: String, upper_bound: String, limit: Int64, key_type: String, index_position: String, reverse: Bool, show_payer: Bool) throws {
    try outProtocol.writeMessageBegin(name: "get_table_rows", type: .call, sequenceID: 0)
    let args = IPCChainTester_get_table_rows_args(id: id, json: json, code: code, scope: scope, table: table, lower_bound: lower_bound, upper_bound: upper_bound, limit: limit, key_type: key_type, index_position: index_position, reverse: reverse, show_payer: show_payer)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_table_rows() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try IPCChainTester_get_table_rows_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_table_rows"))
  }

  public func get_table_rows(id: Int32, json: Bool, code: String, scope: String, table: String, lower_bound: String, upper_bound: String, limit: Int64, key_type: String, index_position: String, reverse: Bool, show_payer: Bool) throws -> String {
    try send_get_table_rows(id: id, json: json, code: code, scope: scope, table: table, lower_bound: lower_bound, upper_bound: upper_bound, limit: limit, key_type: key_type, index_position: index_position, reverse: reverse, show_payer: show_payer)
    try outProtocol.transport.flush()
    return try recv_get_table_rows()
  }

}

extension IPCChainTesterProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["init_vm_api"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_init_vm_api_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

    }
    processorHandlers["init_apply_request"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_init_apply_request_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

    }
    processorHandlers["enable_debug_contract"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_enable_debug_contract_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_enable_debug_contract_result()
      do {
        try handler.enable_debug_contract(id: args.id, contract: args.contract, enable: args.enable)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "enable_debug_contract", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["is_debug_contract_enabled"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_is_debug_contract_enabled_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_is_debug_contract_enabled_result()
      do {
        result.success = try handler.is_debug_contract_enabled(id: args.id, contract: args.contract)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "is_debug_contract_enabled", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["pack_abi"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_pack_abi_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_pack_abi_result()
      do {
        result.success = try handler.pack_abi(abi: args.abi)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "pack_abi", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["pack_action_args"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_pack_action_args_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_pack_action_args_result()
      do {
        result.success = try handler.pack_action_args(id: args.id, contract: args.contract, action: args.action, action_args: args.action_args)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "pack_action_args", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["unpack_action_args"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_unpack_action_args_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_unpack_action_args_result()
      do {
        result.success = try handler.unpack_action_args(id: args.id, contract: args.contract, action: args.action, raw_args: args.raw_args)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unpack_action_args", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["new_chain"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_new_chain_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_new_chain_result()
      do {
        result.success = try handler.new_chain()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "new_chain", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["free_chain"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_free_chain_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_free_chain_result()
      do {
        result.success = try handler.free_chain(id: args.id)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "free_chain", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_info"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_get_info_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_get_info_result()
      do {
        result.success = try handler.get_info(id: args.id)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_info", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["create_key"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_create_key_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_create_key_result()
      do {
        result.success = try handler.create_key(key_type: args.key_type)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "create_key", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_account"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_get_account_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_get_account_result()
      do {
        result.success = try handler.get_account(id: args.id, account: args.account)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_account", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["create_account"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_create_account_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_create_account_result()
      do {
        result.success = try handler.create_account(id: args.id, creator: args.creator, account: args.account, owner_key: args.owner_key, active_key: args.active_key, ram_bytes: args.ram_bytes, stake_net: args.stake_net, stake_cpu: args.stake_cpu)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "create_account", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["import_key"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_import_key_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_import_key_result()
      do {
        result.success = try handler.import_key(id: args.id, pub_key: args.pub_key, priv_key: args.priv_key)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "import_key", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_required_keys"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_get_required_keys_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_get_required_keys_result()
      do {
        result.success = try handler.get_required_keys(id: args.id, transaction: args.transaction, available_keys: args.available_keys)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_required_keys", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["produce_block"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_produce_block_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_produce_block_result()
      do {
        try handler.produce_block(id: args.id, next_block_skip_seconds: args.next_block_skip_seconds)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "produce_block", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["push_action"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_push_action_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_push_action_result()
      do {
        result.success = try handler.push_action(id: args.id, account: args.account, action: args.action, arguments: args.arguments, permissions: args.permissions)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "push_action", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["push_actions"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_push_actions_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_push_actions_result()
      do {
        result.success = try handler.push_actions(id: args.id, actions: args.actions)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "push_actions", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_table_rows"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try IPCChainTester_get_table_rows_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = IPCChainTester_get_table_rows_result()
      do {
        result.success = try handler.get_table_rows(id: args.id, json: args.json, code: args.code, scope: args.scope, table: args.table, lower_bound: args.lower_bound, upper_bound: args.upper_bound, limit: args.limit, key_type: args.key_type, index_position: args.index_position, reverse: args.reverse, show_payer: args.show_payer)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_table_rows", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = IPCChainTesterProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

fileprivate final class PushActions_push_actions_args {

  fileprivate var actions: TList<Action>


  fileprivate init(actions: TList<Action>) {
    self.actions = actions
  }

}

fileprivate func ==(lhs: PushActions_push_actions_args, rhs: PushActions_push_actions_args) -> Bool {
  return
    (lhs.actions == rhs.actions)
}

extension PushActions_push_actions_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(actions)
  }

}

extension PushActions_push_actions_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["actions": 1, ]
  }

  fileprivate static var structName: String { return "PushActions_push_actions_args" }

  fileprivate static func read(from proto: TProtocol) throws -> PushActions_push_actions_args {
    _ = try proto.readStructBegin()
    var actions: TList<Action>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            actions = try TList<Action>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(actions, named: "actions")

    return PushActions_push_actions_args(actions: actions)
  }

}



fileprivate final class PushActions_push_actions_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: PushActions_push_actions_result, rhs: PushActions_push_actions_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension PushActions_push_actions_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension PushActions_push_actions_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "PushActions_push_actions_result" }

  fileprivate static func read(from proto: TProtocol) throws -> PushActions_push_actions_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return PushActions_push_actions_result(success: success)
  }

}



extension PushActionsClient : PushActions {

  private func send_push_actions(actions: TList<Action>) throws {
    try outProtocol.writeMessageBegin(name: "push_actions", type: .call, sequenceID: 0)
    let args = PushActions_push_actions_args(actions: actions)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_push_actions() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try PushActions_push_actions_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "push_actions"))
  }

  public func push_actions(actions: TList<Action>) throws -> Int32 {
    try send_push_actions(actions: actions)
    try outProtocol.transport.flush()
    return try recv_push_actions()
  }

}

extension PushActionsProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["push_actions"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try PushActions_push_actions_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = PushActions_push_actions_result()
      do {
        result.success = try handler.push_actions(actions: args.actions)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "push_actions", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = PushActionsProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

fileprivate final class ApplyRequest_apply_request_args {

  fileprivate var receiver: Uint64

  fileprivate var firstReceiver: Uint64

  fileprivate var action: Uint64


  fileprivate init(receiver: Uint64, firstReceiver: Uint64, action: Uint64) {
    self.receiver = receiver
    self.firstReceiver = firstReceiver
    self.action = action
  }

}

fileprivate func ==(lhs: ApplyRequest_apply_request_args, rhs: ApplyRequest_apply_request_args) -> Bool {
  return
    (lhs.receiver == rhs.receiver) &&
    (lhs.firstReceiver == rhs.firstReceiver) &&
    (lhs.action == rhs.action)
}

extension ApplyRequest_apply_request_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(receiver)
    hasher.combine(firstReceiver)
    hasher.combine(action)
  }

}

extension ApplyRequest_apply_request_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["receiver": 1, "firstReceiver": 2, "action": 3, ]
  }

  fileprivate static var structName: String { return "ApplyRequest_apply_request_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ApplyRequest_apply_request_args {
    _ = try proto.readStructBegin()
    var receiver: Uint64!
    var firstReceiver: Uint64!
    var action: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           receiver = try Uint64.read(from: proto)
        case (2, .struct):           firstReceiver = try Uint64.read(from: proto)
        case (3, .struct):           action = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(receiver, named: "receiver")
    try proto.validateValue(firstReceiver, named: "firstReceiver")
    try proto.validateValue(action, named: "action")

    return ApplyRequest_apply_request_args(receiver: receiver, firstReceiver: firstReceiver, action: action)
  }

}



fileprivate final class ApplyRequest_apply_request_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: ApplyRequest_apply_request_result, rhs: ApplyRequest_apply_request_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension ApplyRequest_apply_request_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension ApplyRequest_apply_request_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "ApplyRequest_apply_request_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ApplyRequest_apply_request_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ApplyRequest_apply_request_result(success: success)
  }

}



fileprivate final class ApplyRequest_apply_end_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: ApplyRequest_apply_end_args, rhs: ApplyRequest_apply_end_args) -> Bool {
  return true
}

extension ApplyRequest_apply_end_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension ApplyRequest_apply_end_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "ApplyRequest_apply_end_args" }

  fileprivate static func read(from proto: TProtocol) throws -> ApplyRequest_apply_end_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ApplyRequest_apply_end_args()
  }

}



fileprivate final class ApplyRequest_apply_end_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: ApplyRequest_apply_end_result, rhs: ApplyRequest_apply_end_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension ApplyRequest_apply_end_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension ApplyRequest_apply_end_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "ApplyRequest_apply_end_result" }

  fileprivate static func read(from proto: TProtocol) throws -> ApplyRequest_apply_end_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return ApplyRequest_apply_end_result(success: success)
  }

}



extension ApplyRequestClient : ApplyRequest {

  private func send_apply_request(receiver: Uint64, firstReceiver: Uint64, action: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "apply_request", type: .call, sequenceID: 0)
    let args = ApplyRequest_apply_request_args(receiver: receiver, firstReceiver: firstReceiver, action: action)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_apply_request() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try ApplyRequest_apply_request_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "apply_request"))
  }

  public func apply_request(receiver: Uint64, firstReceiver: Uint64, action: Uint64) throws -> Int32 {
    try send_apply_request(receiver: receiver, firstReceiver: firstReceiver, action: action)
    try outProtocol.transport.flush()
    return try recv_apply_request()
  }

  private func send_apply_end() throws {
    try outProtocol.writeMessageBegin(name: "apply_end", type: .call, sequenceID: 0)
    let args = ApplyRequest_apply_end_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_apply_end() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try ApplyRequest_apply_end_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "apply_end"))
  }

  public func apply_end() throws -> Int32 {
    try send_apply_end()
    try outProtocol.transport.flush()
    return try recv_apply_end()
  }

}

extension ApplyRequestProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["apply_request"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ApplyRequest_apply_request_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ApplyRequest_apply_request_result()
      do {
        result.success = try handler.apply_request(receiver: args.receiver, firstReceiver: args.firstReceiver, action: args.action)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "apply_request", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["apply_end"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ApplyRequest_apply_end_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = ApplyRequest_apply_end_result()
      do {
        result.success = try handler.apply_end()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "apply_end", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = ApplyRequestProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
      
      if messageName == "apply_end" {
          throw TApplicationError( thriftErrorCode: 0, message: "apply_end")
      }
  }
}

fileprivate final class Apply_end_apply_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_end_apply_args, rhs: Apply_end_apply_args) -> Bool {
  return true
}

extension Apply_end_apply_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_end_apply_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_end_apply_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_end_apply_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_end_apply_args()
  }

}



fileprivate final class Apply_end_apply_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_end_apply_result, rhs: Apply_end_apply_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_end_apply_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_end_apply_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_end_apply_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_end_apply_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_end_apply_result(success: success)
  }

}



fileprivate final class Apply_get_active_producers_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_get_active_producers_args, rhs: Apply_get_active_producers_args) -> Bool {
  return true
}

extension Apply_get_active_producers_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_get_active_producers_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_get_active_producers_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_active_producers_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_active_producers_args()
  }

}



fileprivate final class Apply_get_active_producers_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_get_active_producers_result, rhs: Apply_get_active_producers_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_get_active_producers_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_get_active_producers_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_get_active_producers_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_active_producers_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_active_producers_result(success: success)
  }

}



fileprivate final class Apply_get_resource_limits_args {

  fileprivate var account: Uint64


  fileprivate init(account: Uint64) {
    self.account = account
  }

}

fileprivate func ==(lhs: Apply_get_resource_limits_args, rhs: Apply_get_resource_limits_args) -> Bool {
  return
    (lhs.account == rhs.account)
}

extension Apply_get_resource_limits_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(account)
  }

}

extension Apply_get_resource_limits_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["account": 1, ]
  }

  fileprivate static var structName: String { return "Apply_get_resource_limits_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_resource_limits_args {
    _ = try proto.readStructBegin()
    var account: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           account = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(account, named: "account")

    return Apply_get_resource_limits_args(account: account)
  }

}



fileprivate final class Apply_get_resource_limits_result {

  fileprivate var success: GetResourceLimitsReturn?


  fileprivate init() { }
  fileprivate init(success: GetResourceLimitsReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_get_resource_limits_result, rhs: Apply_get_resource_limits_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_get_resource_limits_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_get_resource_limits_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_get_resource_limits_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_resource_limits_result {
    _ = try proto.readStructBegin()
    var success: GetResourceLimitsReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try GetResourceLimitsReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_resource_limits_result(success: success)
  }

}



fileprivate final class Apply_set_resource_limits_args {

  fileprivate var account: Uint64

  fileprivate var ram_bytes: Int64

  fileprivate var net_weight: Int64

  fileprivate var cpu_weight: Int64


  fileprivate init(account: Uint64, ram_bytes: Int64, net_weight: Int64, cpu_weight: Int64) {
    self.account = account
    self.ram_bytes = ram_bytes
    self.net_weight = net_weight
    self.cpu_weight = cpu_weight
  }

}

fileprivate func ==(lhs: Apply_set_resource_limits_args, rhs: Apply_set_resource_limits_args) -> Bool {
  return
    (lhs.account == rhs.account) &&
    (lhs.ram_bytes == rhs.ram_bytes) &&
    (lhs.net_weight == rhs.net_weight) &&
    (lhs.cpu_weight == rhs.cpu_weight)
}

extension Apply_set_resource_limits_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(account)
    hasher.combine(ram_bytes)
    hasher.combine(net_weight)
    hasher.combine(cpu_weight)
  }

}

extension Apply_set_resource_limits_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["account": 1, "ram_bytes": 2, "net_weight": 3, "cpu_weight": 4, ]
  }

  fileprivate static var structName: String { return "Apply_set_resource_limits_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_set_resource_limits_args {
    _ = try proto.readStructBegin()
    var account: Uint64!
    var ram_bytes: Int64!
    var net_weight: Int64!
    var cpu_weight: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           account = try Uint64.read(from: proto)
        case (2, .i64):             ram_bytes = try Int64.read(from: proto)
        case (3, .i64):             net_weight = try Int64.read(from: proto)
        case (4, .i64):             cpu_weight = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(account, named: "account")
    try proto.validateValue(ram_bytes, named: "ram_bytes")
    try proto.validateValue(net_weight, named: "net_weight")
    try proto.validateValue(cpu_weight, named: "cpu_weight")

    return Apply_set_resource_limits_args(account: account, ram_bytes: ram_bytes, net_weight: net_weight, cpu_weight: cpu_weight)
  }

}



fileprivate final class Apply_set_resource_limits_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_set_resource_limits_result, rhs: Apply_set_resource_limits_result) -> Bool {
  return true
}

extension Apply_set_resource_limits_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_set_resource_limits_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_set_resource_limits_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_set_resource_limits_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_set_resource_limits_result()
  }

}



fileprivate final class Apply_set_proposed_producers_args {

  fileprivate var producer_data: Data


  fileprivate init(producer_data: Data) {
    self.producer_data = producer_data
  }

}

fileprivate func ==(lhs: Apply_set_proposed_producers_args, rhs: Apply_set_proposed_producers_args) -> Bool {
  return
    (lhs.producer_data == rhs.producer_data)
}

extension Apply_set_proposed_producers_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(producer_data)
  }

}

extension Apply_set_proposed_producers_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["producer_data": 1, ]
  }

  fileprivate static var structName: String { return "Apply_set_proposed_producers_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_set_proposed_producers_args {
    _ = try proto.readStructBegin()
    var producer_data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           producer_data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(producer_data, named: "producer_data")

    return Apply_set_proposed_producers_args(producer_data: producer_data)
  }

}



fileprivate final class Apply_set_proposed_producers_result {

  fileprivate var success: Int64?


  fileprivate init() { }
  fileprivate init(success: Int64?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_set_proposed_producers_result, rhs: Apply_set_proposed_producers_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_set_proposed_producers_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_set_proposed_producers_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_set_proposed_producers_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_set_proposed_producers_result {
    _ = try proto.readStructBegin()
    var success: Int64?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_set_proposed_producers_result(success: success)
  }

}



fileprivate final class Apply_set_proposed_producers_ex_args {

  fileprivate var producer_data_format: Uint64

  fileprivate var producer_data: Data


  fileprivate init(producer_data_format: Uint64, producer_data: Data) {
    self.producer_data_format = producer_data_format
    self.producer_data = producer_data
  }

}

fileprivate func ==(lhs: Apply_set_proposed_producers_ex_args, rhs: Apply_set_proposed_producers_ex_args) -> Bool {
  return
    (lhs.producer_data_format == rhs.producer_data_format) &&
    (lhs.producer_data == rhs.producer_data)
}

extension Apply_set_proposed_producers_ex_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(producer_data_format)
    hasher.combine(producer_data)
  }

}

extension Apply_set_proposed_producers_ex_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["producer_data_format": 1, "producer_data": 2, ]
  }

  fileprivate static var structName: String { return "Apply_set_proposed_producers_ex_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_set_proposed_producers_ex_args {
    _ = try proto.readStructBegin()
    var producer_data_format: Uint64!
    var producer_data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           producer_data_format = try Uint64.read(from: proto)
        case (2, .string):           producer_data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(producer_data_format, named: "producer_data_format")
    try proto.validateValue(producer_data, named: "producer_data")

    return Apply_set_proposed_producers_ex_args(producer_data_format: producer_data_format, producer_data: producer_data)
  }

}



fileprivate final class Apply_set_proposed_producers_ex_result {

  fileprivate var success: Int64?


  fileprivate init() { }
  fileprivate init(success: Int64?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_set_proposed_producers_ex_result, rhs: Apply_set_proposed_producers_ex_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_set_proposed_producers_ex_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_set_proposed_producers_ex_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_set_proposed_producers_ex_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_set_proposed_producers_ex_result {
    _ = try proto.readStructBegin()
    var success: Int64?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_set_proposed_producers_ex_result(success: success)
  }

}



fileprivate final class Apply_is_privileged_args {

  fileprivate var account: Uint64


  fileprivate init(account: Uint64) {
    self.account = account
  }

}

fileprivate func ==(lhs: Apply_is_privileged_args, rhs: Apply_is_privileged_args) -> Bool {
  return
    (lhs.account == rhs.account)
}

extension Apply_is_privileged_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(account)
  }

}

extension Apply_is_privileged_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["account": 1, ]
  }

  fileprivate static var structName: String { return "Apply_is_privileged_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_is_privileged_args {
    _ = try proto.readStructBegin()
    var account: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           account = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(account, named: "account")

    return Apply_is_privileged_args(account: account)
  }

}



fileprivate final class Apply_is_privileged_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_is_privileged_result, rhs: Apply_is_privileged_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_is_privileged_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_is_privileged_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_is_privileged_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_is_privileged_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_is_privileged_result(success: success)
  }

}



fileprivate final class Apply_set_privileged_args {

  fileprivate var account: Uint64

  fileprivate var is_priv: Bool


  fileprivate init(account: Uint64, is_priv: Bool) {
    self.account = account
    self.is_priv = is_priv
  }

}

fileprivate func ==(lhs: Apply_set_privileged_args, rhs: Apply_set_privileged_args) -> Bool {
  return
    (lhs.account == rhs.account) &&
    (lhs.is_priv == rhs.is_priv)
}

extension Apply_set_privileged_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(account)
    hasher.combine(is_priv)
  }

}

extension Apply_set_privileged_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["account": 1, "is_priv": 2, ]
  }

  fileprivate static var structName: String { return "Apply_set_privileged_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_set_privileged_args {
    _ = try proto.readStructBegin()
    var account: Uint64!
    var is_priv: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           account = try Uint64.read(from: proto)
        case (2, .bool):            is_priv = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(account, named: "account")
    try proto.validateValue(is_priv, named: "is_priv")

    return Apply_set_privileged_args(account: account, is_priv: is_priv)
  }

}



fileprivate final class Apply_set_privileged_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_set_privileged_result, rhs: Apply_set_privileged_result) -> Bool {
  return true
}

extension Apply_set_privileged_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_set_privileged_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_set_privileged_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_set_privileged_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_set_privileged_result()
  }

}



fileprivate final class Apply_set_blockchain_parameters_packed_args {

  fileprivate var data: Data


  fileprivate init(data: Data) {
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_set_blockchain_parameters_packed_args, rhs: Apply_set_blockchain_parameters_packed_args) -> Bool {
  return
    (lhs.data == rhs.data)
}

extension Apply_set_blockchain_parameters_packed_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(data)
  }

}

extension Apply_set_blockchain_parameters_packed_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, ]
  }

  fileprivate static var structName: String { return "Apply_set_blockchain_parameters_packed_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_set_blockchain_parameters_packed_args {
    _ = try proto.readStructBegin()
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")

    return Apply_set_blockchain_parameters_packed_args(data: data)
  }

}



fileprivate final class Apply_set_blockchain_parameters_packed_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_set_blockchain_parameters_packed_result, rhs: Apply_set_blockchain_parameters_packed_result) -> Bool {
  return true
}

extension Apply_set_blockchain_parameters_packed_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_set_blockchain_parameters_packed_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_set_blockchain_parameters_packed_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_set_blockchain_parameters_packed_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_set_blockchain_parameters_packed_result()
  }

}



fileprivate final class Apply_get_blockchain_parameters_packed_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_get_blockchain_parameters_packed_args, rhs: Apply_get_blockchain_parameters_packed_args) -> Bool {
  return true
}

extension Apply_get_blockchain_parameters_packed_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_get_blockchain_parameters_packed_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_get_blockchain_parameters_packed_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_blockchain_parameters_packed_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_blockchain_parameters_packed_args()
  }

}



fileprivate final class Apply_get_blockchain_parameters_packed_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_get_blockchain_parameters_packed_result, rhs: Apply_get_blockchain_parameters_packed_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_get_blockchain_parameters_packed_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_get_blockchain_parameters_packed_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_get_blockchain_parameters_packed_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_blockchain_parameters_packed_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_blockchain_parameters_packed_result(success: success)
  }

}



fileprivate final class Apply_preactivate_feature_args {

  fileprivate var feature_digest: Data


  fileprivate init(feature_digest: Data) {
    self.feature_digest = feature_digest
  }

}

fileprivate func ==(lhs: Apply_preactivate_feature_args, rhs: Apply_preactivate_feature_args) -> Bool {
  return
    (lhs.feature_digest == rhs.feature_digest)
}

extension Apply_preactivate_feature_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(feature_digest)
  }

}

extension Apply_preactivate_feature_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["feature_digest": 1, ]
  }

  fileprivate static var structName: String { return "Apply_preactivate_feature_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_preactivate_feature_args {
    _ = try proto.readStructBegin()
    var feature_digest: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           feature_digest = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(feature_digest, named: "feature_digest")

    return Apply_preactivate_feature_args(feature_digest: feature_digest)
  }

}



fileprivate final class Apply_preactivate_feature_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_preactivate_feature_result, rhs: Apply_preactivate_feature_result) -> Bool {
  return true
}

extension Apply_preactivate_feature_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_preactivate_feature_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_preactivate_feature_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_preactivate_feature_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_preactivate_feature_result()
  }

}



fileprivate final class Apply_check_transaction_authorization_args {

  fileprivate var trx_data: Data

  fileprivate var pubkeys_data: Data

  fileprivate var perms_data: Data


  fileprivate init(trx_data: Data, pubkeys_data: Data, perms_data: Data) {
    self.trx_data = trx_data
    self.pubkeys_data = pubkeys_data
    self.perms_data = perms_data
  }

}

fileprivate func ==(lhs: Apply_check_transaction_authorization_args, rhs: Apply_check_transaction_authorization_args) -> Bool {
  return
    (lhs.trx_data == rhs.trx_data) &&
    (lhs.pubkeys_data == rhs.pubkeys_data) &&
    (lhs.perms_data == rhs.perms_data)
}

extension Apply_check_transaction_authorization_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(trx_data)
    hasher.combine(pubkeys_data)
    hasher.combine(perms_data)
  }

}

extension Apply_check_transaction_authorization_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["trx_data": 1, "pubkeys_data": 2, "perms_data": 3, ]
  }

  fileprivate static var structName: String { return "Apply_check_transaction_authorization_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_check_transaction_authorization_args {
    _ = try proto.readStructBegin()
    var trx_data: Data!
    var pubkeys_data: Data!
    var perms_data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           trx_data = try Data.read(from: proto)
        case (2, .string):           pubkeys_data = try Data.read(from: proto)
        case (3, .string):           perms_data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(trx_data, named: "trx_data")
    try proto.validateValue(pubkeys_data, named: "pubkeys_data")
    try proto.validateValue(perms_data, named: "perms_data")

    return Apply_check_transaction_authorization_args(trx_data: trx_data, pubkeys_data: pubkeys_data, perms_data: perms_data)
  }

}



fileprivate final class Apply_check_transaction_authorization_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_check_transaction_authorization_result, rhs: Apply_check_transaction_authorization_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_check_transaction_authorization_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_check_transaction_authorization_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_check_transaction_authorization_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_check_transaction_authorization_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_check_transaction_authorization_result(success: success)
  }

}



fileprivate final class Apply_check_permission_authorization_args {

  fileprivate var account: Uint64

  fileprivate var permission: Uint64

  fileprivate var pubkeys_data: Data

  fileprivate var perms_data: Data

  fileprivate var delay_us: Uint64


  fileprivate init(account: Uint64, permission: Uint64, pubkeys_data: Data, perms_data: Data, delay_us: Uint64) {
    self.account = account
    self.permission = permission
    self.pubkeys_data = pubkeys_data
    self.perms_data = perms_data
    self.delay_us = delay_us
  }

}

fileprivate func ==(lhs: Apply_check_permission_authorization_args, rhs: Apply_check_permission_authorization_args) -> Bool {
  return
    (lhs.account == rhs.account) &&
    (lhs.permission == rhs.permission) &&
    (lhs.pubkeys_data == rhs.pubkeys_data) &&
    (lhs.perms_data == rhs.perms_data) &&
    (lhs.delay_us == rhs.delay_us)
}

extension Apply_check_permission_authorization_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(account)
    hasher.combine(permission)
    hasher.combine(pubkeys_data)
    hasher.combine(perms_data)
    hasher.combine(delay_us)
  }

}

extension Apply_check_permission_authorization_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["account": 1, "permission": 2, "pubkeys_data": 3, "perms_data": 4, "delay_us": 5, ]
  }

  fileprivate static var structName: String { return "Apply_check_permission_authorization_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_check_permission_authorization_args {
    _ = try proto.readStructBegin()
    var account: Uint64!
    var permission: Uint64!
    var pubkeys_data: Data!
    var perms_data: Data!
    var delay_us: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           account = try Uint64.read(from: proto)
        case (2, .struct):           permission = try Uint64.read(from: proto)
        case (3, .string):           pubkeys_data = try Data.read(from: proto)
        case (4, .string):           perms_data = try Data.read(from: proto)
        case (5, .struct):           delay_us = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(account, named: "account")
    try proto.validateValue(permission, named: "permission")
    try proto.validateValue(pubkeys_data, named: "pubkeys_data")
    try proto.validateValue(perms_data, named: "perms_data")
    try proto.validateValue(delay_us, named: "delay_us")

    return Apply_check_permission_authorization_args(account: account, permission: permission, pubkeys_data: pubkeys_data, perms_data: perms_data, delay_us: delay_us)
  }

}



fileprivate final class Apply_check_permission_authorization_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_check_permission_authorization_result, rhs: Apply_check_permission_authorization_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_check_permission_authorization_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_check_permission_authorization_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_check_permission_authorization_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_check_permission_authorization_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_check_permission_authorization_result(success: success)
  }

}



fileprivate final class Apply_get_permission_last_used_args {

  fileprivate var account: Uint64

  fileprivate var permission: Uint64


  fileprivate init(account: Uint64, permission: Uint64) {
    self.account = account
    self.permission = permission
  }

}

fileprivate func ==(lhs: Apply_get_permission_last_used_args, rhs: Apply_get_permission_last_used_args) -> Bool {
  return
    (lhs.account == rhs.account) &&
    (lhs.permission == rhs.permission)
}

extension Apply_get_permission_last_used_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(account)
    hasher.combine(permission)
  }

}

extension Apply_get_permission_last_used_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["account": 1, "permission": 2, ]
  }

  fileprivate static var structName: String { return "Apply_get_permission_last_used_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_permission_last_used_args {
    _ = try proto.readStructBegin()
    var account: Uint64!
    var permission: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           account = try Uint64.read(from: proto)
        case (2, .struct):           permission = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(account, named: "account")
    try proto.validateValue(permission, named: "permission")

    return Apply_get_permission_last_used_args(account: account, permission: permission)
  }

}



fileprivate final class Apply_get_permission_last_used_result {

  fileprivate var success: Int64?


  fileprivate init() { }
  fileprivate init(success: Int64?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_get_permission_last_used_result, rhs: Apply_get_permission_last_used_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_get_permission_last_used_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_get_permission_last_used_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_get_permission_last_used_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_permission_last_used_result {
    _ = try proto.readStructBegin()
    var success: Int64?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_permission_last_used_result(success: success)
  }

}



fileprivate final class Apply_get_account_creation_time_args {

  fileprivate var account: Uint64


  fileprivate init(account: Uint64) {
    self.account = account
  }

}

fileprivate func ==(lhs: Apply_get_account_creation_time_args, rhs: Apply_get_account_creation_time_args) -> Bool {
  return
    (lhs.account == rhs.account)
}

extension Apply_get_account_creation_time_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(account)
  }

}

extension Apply_get_account_creation_time_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["account": 1, ]
  }

  fileprivate static var structName: String { return "Apply_get_account_creation_time_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_account_creation_time_args {
    _ = try proto.readStructBegin()
    var account: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           account = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(account, named: "account")

    return Apply_get_account_creation_time_args(account: account)
  }

}



fileprivate final class Apply_get_account_creation_time_result {

  fileprivate var success: Int64?


  fileprivate init() { }
  fileprivate init(success: Int64?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_get_account_creation_time_result, rhs: Apply_get_account_creation_time_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_get_account_creation_time_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_get_account_creation_time_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_get_account_creation_time_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_account_creation_time_result {
    _ = try proto.readStructBegin()
    var success: Int64?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_account_creation_time_result(success: success)
  }

}



fileprivate final class Apply_prints_args {

  fileprivate var cstr: String


  fileprivate init(cstr: String) {
    self.cstr = cstr
  }

}

fileprivate func ==(lhs: Apply_prints_args, rhs: Apply_prints_args) -> Bool {
  return
    (lhs.cstr == rhs.cstr)
}

extension Apply_prints_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(cstr)
  }

}

extension Apply_prints_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["cstr": 1, ]
  }

  fileprivate static var structName: String { return "Apply_prints_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_prints_args {
    _ = try proto.readStructBegin()
    var cstr: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           cstr = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(cstr, named: "cstr")

    return Apply_prints_args(cstr: cstr)
  }

}



fileprivate final class Apply_prints_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_prints_result, rhs: Apply_prints_result) -> Bool {
  return true
}

extension Apply_prints_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_prints_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_prints_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_prints_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_prints_result()
  }

}



fileprivate final class Apply_prints_l_args {

  fileprivate var cstr: Data


  fileprivate init(cstr: Data) {
    self.cstr = cstr
  }

}

fileprivate func ==(lhs: Apply_prints_l_args, rhs: Apply_prints_l_args) -> Bool {
  return
    (lhs.cstr == rhs.cstr)
}

extension Apply_prints_l_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(cstr)
  }

}

extension Apply_prints_l_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["cstr": 1, ]
  }

  fileprivate static var structName: String { return "Apply_prints_l_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_prints_l_args {
    _ = try proto.readStructBegin()
    var cstr: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           cstr = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(cstr, named: "cstr")

    return Apply_prints_l_args(cstr: cstr)
  }

}



fileprivate final class Apply_prints_l_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_prints_l_result, rhs: Apply_prints_l_result) -> Bool {
  return true
}

extension Apply_prints_l_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_prints_l_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_prints_l_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_prints_l_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_prints_l_result()
  }

}



fileprivate final class Apply_printi_args {

  fileprivate var n: Int64


  fileprivate init(n: Int64) {
    self.n = n
  }

}

fileprivate func ==(lhs: Apply_printi_args, rhs: Apply_printi_args) -> Bool {
  return
    (lhs.n == rhs.n)
}

extension Apply_printi_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(n)
  }

}

extension Apply_printi_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["n": 1, ]
  }

  fileprivate static var structName: String { return "Apply_printi_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printi_args {
    _ = try proto.readStructBegin()
    var n: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             n = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(n, named: "n")

    return Apply_printi_args(n: n)
  }

}



fileprivate final class Apply_printi_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_printi_result, rhs: Apply_printi_result) -> Bool {
  return true
}

extension Apply_printi_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_printi_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_printi_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printi_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_printi_result()
  }

}



fileprivate final class Apply_printui_args {

  fileprivate var n: Uint64


  fileprivate init(n: Uint64) {
    self.n = n
  }

}

fileprivate func ==(lhs: Apply_printui_args, rhs: Apply_printui_args) -> Bool {
  return
    (lhs.n == rhs.n)
}

extension Apply_printui_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(n)
  }

}

extension Apply_printui_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["n": 1, ]
  }

  fileprivate static var structName: String { return "Apply_printui_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printui_args {
    _ = try proto.readStructBegin()
    var n: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           n = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(n, named: "n")

    return Apply_printui_args(n: n)
  }

}



fileprivate final class Apply_printui_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_printui_result, rhs: Apply_printui_result) -> Bool {
  return true
}

extension Apply_printui_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_printui_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_printui_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printui_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_printui_result()
  }

}



fileprivate final class Apply_printi128_args {

  fileprivate var value: Data


  fileprivate init(value: Data) {
    self.value = value
  }

}

fileprivate func ==(lhs: Apply_printi128_args, rhs: Apply_printi128_args) -> Bool {
  return
    (lhs.value == rhs.value)
}

extension Apply_printi128_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(value)
  }

}

extension Apply_printi128_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["value": 1, ]
  }

  fileprivate static var structName: String { return "Apply_printi128_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printi128_args {
    _ = try proto.readStructBegin()
    var value: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           value = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(value, named: "value")

    return Apply_printi128_args(value: value)
  }

}



fileprivate final class Apply_printi128_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_printi128_result, rhs: Apply_printi128_result) -> Bool {
  return true
}

extension Apply_printi128_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_printi128_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_printi128_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printi128_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_printi128_result()
  }

}



fileprivate final class Apply_printui128_args {

  fileprivate var value: Data


  fileprivate init(value: Data) {
    self.value = value
  }

}

fileprivate func ==(lhs: Apply_printui128_args, rhs: Apply_printui128_args) -> Bool {
  return
    (lhs.value == rhs.value)
}

extension Apply_printui128_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(value)
  }

}

extension Apply_printui128_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["value": 1, ]
  }

  fileprivate static var structName: String { return "Apply_printui128_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printui128_args {
    _ = try proto.readStructBegin()
    var value: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           value = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(value, named: "value")

    return Apply_printui128_args(value: value)
  }

}



fileprivate final class Apply_printui128_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_printui128_result, rhs: Apply_printui128_result) -> Bool {
  return true
}

extension Apply_printui128_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_printui128_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_printui128_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printui128_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_printui128_result()
  }

}



fileprivate final class Apply_printsf_args {

  fileprivate var value: Data


  fileprivate init(value: Data) {
    self.value = value
  }

}

fileprivate func ==(lhs: Apply_printsf_args, rhs: Apply_printsf_args) -> Bool {
  return
    (lhs.value == rhs.value)
}

extension Apply_printsf_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(value)
  }

}

extension Apply_printsf_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["value": 1, ]
  }

  fileprivate static var structName: String { return "Apply_printsf_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printsf_args {
    _ = try proto.readStructBegin()
    var value: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           value = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(value, named: "value")

    return Apply_printsf_args(value: value)
  }

}



fileprivate final class Apply_printsf_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_printsf_result, rhs: Apply_printsf_result) -> Bool {
  return true
}

extension Apply_printsf_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_printsf_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_printsf_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printsf_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_printsf_result()
  }

}



fileprivate final class Apply_printdf_args {

  fileprivate var value: Data


  fileprivate init(value: Data) {
    self.value = value
  }

}

fileprivate func ==(lhs: Apply_printdf_args, rhs: Apply_printdf_args) -> Bool {
  return
    (lhs.value == rhs.value)
}

extension Apply_printdf_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(value)
  }

}

extension Apply_printdf_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["value": 1, ]
  }

  fileprivate static var structName: String { return "Apply_printdf_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printdf_args {
    _ = try proto.readStructBegin()
    var value: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           value = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(value, named: "value")

    return Apply_printdf_args(value: value)
  }

}



fileprivate final class Apply_printdf_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_printdf_result, rhs: Apply_printdf_result) -> Bool {
  return true
}

extension Apply_printdf_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_printdf_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_printdf_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printdf_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_printdf_result()
  }

}



fileprivate final class Apply_printqf_args {

  fileprivate var value: Data


  fileprivate init(value: Data) {
    self.value = value
  }

}

fileprivate func ==(lhs: Apply_printqf_args, rhs: Apply_printqf_args) -> Bool {
  return
    (lhs.value == rhs.value)
}

extension Apply_printqf_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(value)
  }

}

extension Apply_printqf_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["value": 1, ]
  }

  fileprivate static var structName: String { return "Apply_printqf_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printqf_args {
    _ = try proto.readStructBegin()
    var value: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           value = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(value, named: "value")

    return Apply_printqf_args(value: value)
  }

}



fileprivate final class Apply_printqf_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_printqf_result, rhs: Apply_printqf_result) -> Bool {
  return true
}

extension Apply_printqf_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_printqf_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_printqf_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printqf_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_printqf_result()
  }

}



fileprivate final class Apply_printn_args {

  fileprivate var name: Uint64


  fileprivate init(name: Uint64) {
    self.name = name
  }

}

fileprivate func ==(lhs: Apply_printn_args, rhs: Apply_printn_args) -> Bool {
  return
    (lhs.name == rhs.name)
}

extension Apply_printn_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(name)
  }

}

extension Apply_printn_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["name": 1, ]
  }

  fileprivate static var structName: String { return "Apply_printn_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printn_args {
    _ = try proto.readStructBegin()
    var name: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           name = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(name, named: "name")

    return Apply_printn_args(name: name)
  }

}



fileprivate final class Apply_printn_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_printn_result, rhs: Apply_printn_result) -> Bool {
  return true
}

extension Apply_printn_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_printn_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_printn_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printn_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_printn_result()
  }

}



fileprivate final class Apply_printhex_args {

  fileprivate var data: Data


  fileprivate init(data: Data) {
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_printhex_args, rhs: Apply_printhex_args) -> Bool {
  return
    (lhs.data == rhs.data)
}

extension Apply_printhex_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(data)
  }

}

extension Apply_printhex_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, ]
  }

  fileprivate static var structName: String { return "Apply_printhex_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printhex_args {
    _ = try proto.readStructBegin()
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")

    return Apply_printhex_args(data: data)
  }

}



fileprivate final class Apply_printhex_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_printhex_result, rhs: Apply_printhex_result) -> Bool {
  return true
}

extension Apply_printhex_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_printhex_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_printhex_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_printhex_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_printhex_result()
  }

}



fileprivate final class Apply_action_data_size_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_action_data_size_args, rhs: Apply_action_data_size_args) -> Bool {
  return true
}

extension Apply_action_data_size_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_action_data_size_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_action_data_size_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_action_data_size_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_action_data_size_args()
  }

}



fileprivate final class Apply_action_data_size_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_action_data_size_result, rhs: Apply_action_data_size_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_action_data_size_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_action_data_size_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_action_data_size_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_action_data_size_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_action_data_size_result(success: success)
  }

}



fileprivate final class Apply_read_action_data_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_read_action_data_args, rhs: Apply_read_action_data_args) -> Bool {
  return true
}

extension Apply_read_action_data_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_read_action_data_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_read_action_data_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_read_action_data_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_read_action_data_args()
  }

}



fileprivate final class Apply_read_action_data_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_read_action_data_result, rhs: Apply_read_action_data_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_read_action_data_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_read_action_data_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_read_action_data_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_read_action_data_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_read_action_data_result(success: success)
  }

}



fileprivate final class Apply_require_recipient_args {

  fileprivate var name: Uint64


  fileprivate init(name: Uint64) {
    self.name = name
  }

}

fileprivate func ==(lhs: Apply_require_recipient_args, rhs: Apply_require_recipient_args) -> Bool {
  return
    (lhs.name == rhs.name)
}

extension Apply_require_recipient_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(name)
  }

}

extension Apply_require_recipient_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["name": 1, ]
  }

  fileprivate static var structName: String { return "Apply_require_recipient_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_require_recipient_args {
    _ = try proto.readStructBegin()
    var name: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           name = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(name, named: "name")

    return Apply_require_recipient_args(name: name)
  }

}



fileprivate final class Apply_require_recipient_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_require_recipient_result, rhs: Apply_require_recipient_result) -> Bool {
  return true
}

extension Apply_require_recipient_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_require_recipient_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_require_recipient_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_require_recipient_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_require_recipient_result()
  }

}



fileprivate final class Apply_require_auth_args {

  fileprivate var name: Uint64


  fileprivate init(name: Uint64) {
    self.name = name
  }

}

fileprivate func ==(lhs: Apply_require_auth_args, rhs: Apply_require_auth_args) -> Bool {
  return
    (lhs.name == rhs.name)
}

extension Apply_require_auth_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(name)
  }

}

extension Apply_require_auth_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["name": 1, ]
  }

  fileprivate static var structName: String { return "Apply_require_auth_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_require_auth_args {
    _ = try proto.readStructBegin()
    var name: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           name = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(name, named: "name")

    return Apply_require_auth_args(name: name)
  }

}



fileprivate final class Apply_require_auth_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_require_auth_result, rhs: Apply_require_auth_result) -> Bool {
  return true
}

extension Apply_require_auth_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_require_auth_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_require_auth_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_require_auth_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_require_auth_result()
  }

}



fileprivate final class Apply_has_auth_args {

  fileprivate var name: Uint64


  fileprivate init(name: Uint64) {
    self.name = name
  }

}

fileprivate func ==(lhs: Apply_has_auth_args, rhs: Apply_has_auth_args) -> Bool {
  return
    (lhs.name == rhs.name)
}

extension Apply_has_auth_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(name)
  }

}

extension Apply_has_auth_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["name": 1, ]
  }

  fileprivate static var structName: String { return "Apply_has_auth_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_has_auth_args {
    _ = try proto.readStructBegin()
    var name: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           name = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(name, named: "name")

    return Apply_has_auth_args(name: name)
  }

}



fileprivate final class Apply_has_auth_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_has_auth_result, rhs: Apply_has_auth_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_has_auth_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_has_auth_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_has_auth_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_has_auth_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_has_auth_result(success: success)
  }

}



fileprivate final class Apply_require_auth2_args {

  fileprivate var name: Uint64

  fileprivate var permission: Uint64


  fileprivate init(name: Uint64, permission: Uint64) {
    self.name = name
    self.permission = permission
  }

}

fileprivate func ==(lhs: Apply_require_auth2_args, rhs: Apply_require_auth2_args) -> Bool {
  return
    (lhs.name == rhs.name) &&
    (lhs.permission == rhs.permission)
}

extension Apply_require_auth2_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(name)
    hasher.combine(permission)
  }

}

extension Apply_require_auth2_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["name": 1, "permission": 2, ]
  }

  fileprivate static var structName: String { return "Apply_require_auth2_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_require_auth2_args {
    _ = try proto.readStructBegin()
    var name: Uint64!
    var permission: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           name = try Uint64.read(from: proto)
        case (2, .struct):           permission = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(name, named: "name")
    try proto.validateValue(permission, named: "permission")

    return Apply_require_auth2_args(name: name, permission: permission)
  }

}



fileprivate final class Apply_require_auth2_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_require_auth2_result, rhs: Apply_require_auth2_result) -> Bool {
  return true
}

extension Apply_require_auth2_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_require_auth2_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_require_auth2_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_require_auth2_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_require_auth2_result()
  }

}



fileprivate final class Apply_is_account_args {

  fileprivate var name: Uint64


  fileprivate init(name: Uint64) {
    self.name = name
  }

}

fileprivate func ==(lhs: Apply_is_account_args, rhs: Apply_is_account_args) -> Bool {
  return
    (lhs.name == rhs.name)
}

extension Apply_is_account_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(name)
  }

}

extension Apply_is_account_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["name": 1, ]
  }

  fileprivate static var structName: String { return "Apply_is_account_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_is_account_args {
    _ = try proto.readStructBegin()
    var name: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           name = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(name, named: "name")

    return Apply_is_account_args(name: name)
  }

}



fileprivate final class Apply_is_account_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_is_account_result, rhs: Apply_is_account_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_is_account_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_is_account_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_is_account_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_is_account_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_is_account_result(success: success)
  }

}



fileprivate final class Apply_send_inline_args {

  fileprivate var serialized_action: Data


  fileprivate init(serialized_action: Data) {
    self.serialized_action = serialized_action
  }

}

fileprivate func ==(lhs: Apply_send_inline_args, rhs: Apply_send_inline_args) -> Bool {
  return
    (lhs.serialized_action == rhs.serialized_action)
}

extension Apply_send_inline_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(serialized_action)
  }

}

extension Apply_send_inline_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["serialized_action": 1, ]
  }

  fileprivate static var structName: String { return "Apply_send_inline_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_send_inline_args {
    _ = try proto.readStructBegin()
    var serialized_action: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           serialized_action = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(serialized_action, named: "serialized_action")

    return Apply_send_inline_args(serialized_action: serialized_action)
  }

}



fileprivate final class Apply_send_inline_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_send_inline_result, rhs: Apply_send_inline_result) -> Bool {
  return true
}

extension Apply_send_inline_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_send_inline_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_send_inline_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_send_inline_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_send_inline_result()
  }

}



fileprivate final class Apply_send_context_free_inline_args {

  fileprivate var serialized_data: Data


  fileprivate init(serialized_data: Data) {
    self.serialized_data = serialized_data
  }

}

fileprivate func ==(lhs: Apply_send_context_free_inline_args, rhs: Apply_send_context_free_inline_args) -> Bool {
  return
    (lhs.serialized_data == rhs.serialized_data)
}

extension Apply_send_context_free_inline_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(serialized_data)
  }

}

extension Apply_send_context_free_inline_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["serialized_data": 1, ]
  }

  fileprivate static var structName: String { return "Apply_send_context_free_inline_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_send_context_free_inline_args {
    _ = try proto.readStructBegin()
    var serialized_data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           serialized_data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(serialized_data, named: "serialized_data")

    return Apply_send_context_free_inline_args(serialized_data: serialized_data)
  }

}



fileprivate final class Apply_send_context_free_inline_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_send_context_free_inline_result, rhs: Apply_send_context_free_inline_result) -> Bool {
  return true
}

extension Apply_send_context_free_inline_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_send_context_free_inline_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_send_context_free_inline_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_send_context_free_inline_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_send_context_free_inline_result()
  }

}



fileprivate final class Apply_publication_time_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_publication_time_args, rhs: Apply_publication_time_args) -> Bool {
  return true
}

extension Apply_publication_time_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_publication_time_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_publication_time_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_publication_time_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_publication_time_args()
  }

}



fileprivate final class Apply_publication_time_result {

  fileprivate var success: Uint64?


  fileprivate init() { }
  fileprivate init(success: Uint64?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_publication_time_result, rhs: Apply_publication_time_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_publication_time_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_publication_time_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_publication_time_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_publication_time_result {
    _ = try proto.readStructBegin()
    var success: Uint64?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_publication_time_result(success: success)
  }

}



fileprivate final class Apply_current_receiver_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_current_receiver_args, rhs: Apply_current_receiver_args) -> Bool {
  return true
}

extension Apply_current_receiver_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_current_receiver_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_current_receiver_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_current_receiver_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_current_receiver_args()
  }

}



fileprivate final class Apply_current_receiver_result {

  fileprivate var success: Uint64?


  fileprivate init() { }
  fileprivate init(success: Uint64?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_current_receiver_result, rhs: Apply_current_receiver_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_current_receiver_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_current_receiver_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_current_receiver_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_current_receiver_result {
    _ = try proto.readStructBegin()
    var success: Uint64?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_current_receiver_result(success: success)
  }

}



fileprivate final class Apply_eosio_assert_args {

  fileprivate var test: Bool

  fileprivate var msg: Data


  fileprivate init(test: Bool, msg: Data) {
    self.test = test
    self.msg = msg
  }

}

fileprivate func ==(lhs: Apply_eosio_assert_args, rhs: Apply_eosio_assert_args) -> Bool {
  return
    (lhs.test == rhs.test) &&
    (lhs.msg == rhs.msg)
}

extension Apply_eosio_assert_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(test)
    hasher.combine(msg)
  }

}

extension Apply_eosio_assert_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["test": 1, "msg": 2, ]
  }

  fileprivate static var structName: String { return "Apply_eosio_assert_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_eosio_assert_args {
    _ = try proto.readStructBegin()
    var test: Bool!
    var msg: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            test = try Bool.read(from: proto)
        case (2, .string):           msg = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(test, named: "test")
    try proto.validateValue(msg, named: "msg")

    return Apply_eosio_assert_args(test: test, msg: msg)
  }

}



fileprivate final class Apply_eosio_assert_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_eosio_assert_result, rhs: Apply_eosio_assert_result) -> Bool {
  return true
}

extension Apply_eosio_assert_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_eosio_assert_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_eosio_assert_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_eosio_assert_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_eosio_assert_result()
  }

}



fileprivate final class Apply_eosio_assert_message_args {

  fileprivate var test: Bool

  fileprivate var msg: Data


  fileprivate init(test: Bool, msg: Data) {
    self.test = test
    self.msg = msg
  }

}

fileprivate func ==(lhs: Apply_eosio_assert_message_args, rhs: Apply_eosio_assert_message_args) -> Bool {
  return
    (lhs.test == rhs.test) &&
    (lhs.msg == rhs.msg)
}

extension Apply_eosio_assert_message_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(test)
    hasher.combine(msg)
  }

}

extension Apply_eosio_assert_message_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["test": 1, "msg": 2, ]
  }

  fileprivate static var structName: String { return "Apply_eosio_assert_message_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_eosio_assert_message_args {
    _ = try proto.readStructBegin()
    var test: Bool!
    var msg: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            test = try Bool.read(from: proto)
        case (2, .string):           msg = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(test, named: "test")
    try proto.validateValue(msg, named: "msg")

    return Apply_eosio_assert_message_args(test: test, msg: msg)
  }

}



fileprivate final class Apply_eosio_assert_message_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_eosio_assert_message_result, rhs: Apply_eosio_assert_message_result) -> Bool {
  return true
}

extension Apply_eosio_assert_message_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_eosio_assert_message_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_eosio_assert_message_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_eosio_assert_message_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_eosio_assert_message_result()
  }

}



fileprivate final class Apply_eosio_assert_code_args {

  fileprivate var test: Bool

  fileprivate var code: Uint64


  fileprivate init(test: Bool, code: Uint64) {
    self.test = test
    self.code = code
  }

}

fileprivate func ==(lhs: Apply_eosio_assert_code_args, rhs: Apply_eosio_assert_code_args) -> Bool {
  return
    (lhs.test == rhs.test) &&
    (lhs.code == rhs.code)
}

extension Apply_eosio_assert_code_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(test)
    hasher.combine(code)
  }

}

extension Apply_eosio_assert_code_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["test": 1, "code": 2, ]
  }

  fileprivate static var structName: String { return "Apply_eosio_assert_code_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_eosio_assert_code_args {
    _ = try proto.readStructBegin()
    var test: Bool!
    var code: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            test = try Bool.read(from: proto)
        case (2, .struct):           code = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(test, named: "test")
    try proto.validateValue(code, named: "code")

    return Apply_eosio_assert_code_args(test: test, code: code)
  }

}



fileprivate final class Apply_eosio_assert_code_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_eosio_assert_code_result, rhs: Apply_eosio_assert_code_result) -> Bool {
  return true
}

extension Apply_eosio_assert_code_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_eosio_assert_code_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_eosio_assert_code_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_eosio_assert_code_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_eosio_assert_code_result()
  }

}



fileprivate final class Apply_eosio_exit_args {

  fileprivate var code: Int32


  fileprivate init(code: Int32) {
    self.code = code
  }

}

fileprivate func ==(lhs: Apply_eosio_exit_args, rhs: Apply_eosio_exit_args) -> Bool {
  return
    (lhs.code == rhs.code)
}

extension Apply_eosio_exit_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
  }

}

extension Apply_eosio_exit_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, ]
  }

  fileprivate static var structName: String { return "Apply_eosio_exit_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_eosio_exit_args {
    _ = try proto.readStructBegin()
    var code: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             code = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")

    return Apply_eosio_exit_args(code: code)
  }

}



fileprivate final class Apply_eosio_exit_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_eosio_exit_result, rhs: Apply_eosio_exit_result) -> Bool {
  return true
}

extension Apply_eosio_exit_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_eosio_exit_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_eosio_exit_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_eosio_exit_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_eosio_exit_result()
  }

}



fileprivate final class Apply_current_time_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_current_time_args, rhs: Apply_current_time_args) -> Bool {
  return true
}

extension Apply_current_time_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_current_time_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_current_time_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_current_time_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_current_time_args()
  }

}



fileprivate final class Apply_current_time_result {

  fileprivate var success: Uint64?


  fileprivate init() { }
  fileprivate init(success: Uint64?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_current_time_result, rhs: Apply_current_time_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_current_time_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_current_time_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_current_time_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_current_time_result {
    _ = try proto.readStructBegin()
    var success: Uint64?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_current_time_result(success: success)
  }

}



fileprivate final class Apply_is_feature_activated_args {

  fileprivate var feature_digest: Data


  fileprivate init(feature_digest: Data) {
    self.feature_digest = feature_digest
  }

}

fileprivate func ==(lhs: Apply_is_feature_activated_args, rhs: Apply_is_feature_activated_args) -> Bool {
  return
    (lhs.feature_digest == rhs.feature_digest)
}

extension Apply_is_feature_activated_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(feature_digest)
  }

}

extension Apply_is_feature_activated_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["feature_digest": 1, ]
  }

  fileprivate static var structName: String { return "Apply_is_feature_activated_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_is_feature_activated_args {
    _ = try proto.readStructBegin()
    var feature_digest: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           feature_digest = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(feature_digest, named: "feature_digest")

    return Apply_is_feature_activated_args(feature_digest: feature_digest)
  }

}



fileprivate final class Apply_is_feature_activated_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_is_feature_activated_result, rhs: Apply_is_feature_activated_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_is_feature_activated_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_is_feature_activated_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_is_feature_activated_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_is_feature_activated_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_is_feature_activated_result(success: success)
  }

}



fileprivate final class Apply_get_sender_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_get_sender_args, rhs: Apply_get_sender_args) -> Bool {
  return true
}

extension Apply_get_sender_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_get_sender_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_get_sender_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_sender_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_sender_args()
  }

}



fileprivate final class Apply_get_sender_result {

  fileprivate var success: Uint64?


  fileprivate init() { }
  fileprivate init(success: Uint64?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_get_sender_result, rhs: Apply_get_sender_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_get_sender_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_get_sender_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_get_sender_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_sender_result {
    _ = try proto.readStructBegin()
    var success: Uint64?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_sender_result(success: success)
  }

}



fileprivate final class Apply_assert_sha256_args {

  fileprivate var data: Data

  fileprivate var hash: Data


  fileprivate init(data: Data, hash: Data) {
    self.data = data
    self.hash = hash
  }

}

fileprivate func ==(lhs: Apply_assert_sha256_args, rhs: Apply_assert_sha256_args) -> Bool {
  return
    (lhs.data == rhs.data) &&
    (lhs.hash == rhs.hash)
}

extension Apply_assert_sha256_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(data)
    hasher.combine(hash)
  }

}

extension Apply_assert_sha256_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, "hash": 2, ]
  }

  fileprivate static var structName: String { return "Apply_assert_sha256_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_assert_sha256_args {
    _ = try proto.readStructBegin()
    var data: Data!
    var hash: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try Data.read(from: proto)
        case (2, .string):           hash = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")
    try proto.validateValue(hash, named: "hash")

    return Apply_assert_sha256_args(data: data, hash: hash)
  }

}



fileprivate final class Apply_assert_sha256_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_assert_sha256_result, rhs: Apply_assert_sha256_result) -> Bool {
  return true
}

extension Apply_assert_sha256_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_assert_sha256_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_assert_sha256_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_assert_sha256_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_assert_sha256_result()
  }

}



fileprivate final class Apply_assert_sha1_args {

  fileprivate var data: Data

  fileprivate var hash: Data


  fileprivate init(data: Data, hash: Data) {
    self.data = data
    self.hash = hash
  }

}

fileprivate func ==(lhs: Apply_assert_sha1_args, rhs: Apply_assert_sha1_args) -> Bool {
  return
    (lhs.data == rhs.data) &&
    (lhs.hash == rhs.hash)
}

extension Apply_assert_sha1_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(data)
    hasher.combine(hash)
  }

}

extension Apply_assert_sha1_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, "hash": 2, ]
  }

  fileprivate static var structName: String { return "Apply_assert_sha1_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_assert_sha1_args {
    _ = try proto.readStructBegin()
    var data: Data!
    var hash: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try Data.read(from: proto)
        case (2, .string):           hash = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")
    try proto.validateValue(hash, named: "hash")

    return Apply_assert_sha1_args(data: data, hash: hash)
  }

}



fileprivate final class Apply_assert_sha1_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_assert_sha1_result, rhs: Apply_assert_sha1_result) -> Bool {
  return true
}

extension Apply_assert_sha1_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_assert_sha1_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_assert_sha1_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_assert_sha1_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_assert_sha1_result()
  }

}



fileprivate final class Apply_assert_sha512_args {

  fileprivate var data: Data

  fileprivate var hash: Data


  fileprivate init(data: Data, hash: Data) {
    self.data = data
    self.hash = hash
  }

}

fileprivate func ==(lhs: Apply_assert_sha512_args, rhs: Apply_assert_sha512_args) -> Bool {
  return
    (lhs.data == rhs.data) &&
    (lhs.hash == rhs.hash)
}

extension Apply_assert_sha512_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(data)
    hasher.combine(hash)
  }

}

extension Apply_assert_sha512_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, "hash": 2, ]
  }

  fileprivate static var structName: String { return "Apply_assert_sha512_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_assert_sha512_args {
    _ = try proto.readStructBegin()
    var data: Data!
    var hash: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try Data.read(from: proto)
        case (2, .string):           hash = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")
    try proto.validateValue(hash, named: "hash")

    return Apply_assert_sha512_args(data: data, hash: hash)
  }

}



fileprivate final class Apply_assert_sha512_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_assert_sha512_result, rhs: Apply_assert_sha512_result) -> Bool {
  return true
}

extension Apply_assert_sha512_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_assert_sha512_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_assert_sha512_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_assert_sha512_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_assert_sha512_result()
  }

}



fileprivate final class Apply_assert_ripemd160_args {

  fileprivate var data: Data

  fileprivate var hash: Data


  fileprivate init(data: Data, hash: Data) {
    self.data = data
    self.hash = hash
  }

}

fileprivate func ==(lhs: Apply_assert_ripemd160_args, rhs: Apply_assert_ripemd160_args) -> Bool {
  return
    (lhs.data == rhs.data) &&
    (lhs.hash == rhs.hash)
}

extension Apply_assert_ripemd160_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(data)
    hasher.combine(hash)
  }

}

extension Apply_assert_ripemd160_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, "hash": 2, ]
  }

  fileprivate static var structName: String { return "Apply_assert_ripemd160_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_assert_ripemd160_args {
    _ = try proto.readStructBegin()
    var data: Data!
    var hash: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try Data.read(from: proto)
        case (2, .string):           hash = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")
    try proto.validateValue(hash, named: "hash")

    return Apply_assert_ripemd160_args(data: data, hash: hash)
  }

}



fileprivate final class Apply_assert_ripemd160_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_assert_ripemd160_result, rhs: Apply_assert_ripemd160_result) -> Bool {
  return true
}

extension Apply_assert_ripemd160_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_assert_ripemd160_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_assert_ripemd160_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_assert_ripemd160_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_assert_ripemd160_result()
  }

}



fileprivate final class Apply_sha256_args {

  fileprivate var data: Data


  fileprivate init(data: Data) {
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_sha256_args, rhs: Apply_sha256_args) -> Bool {
  return
    (lhs.data == rhs.data)
}

extension Apply_sha256_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(data)
  }

}

extension Apply_sha256_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, ]
  }

  fileprivate static var structName: String { return "Apply_sha256_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_sha256_args {
    _ = try proto.readStructBegin()
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")

    return Apply_sha256_args(data: data)
  }

}



fileprivate final class Apply_sha256_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_sha256_result, rhs: Apply_sha256_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_sha256_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_sha256_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_sha256_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_sha256_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_sha256_result(success: success)
  }

}



fileprivate final class Apply_sha1_args {

  fileprivate var data: Data


  fileprivate init(data: Data) {
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_sha1_args, rhs: Apply_sha1_args) -> Bool {
  return
    (lhs.data == rhs.data)
}

extension Apply_sha1_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(data)
  }

}

extension Apply_sha1_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, ]
  }

  fileprivate static var structName: String { return "Apply_sha1_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_sha1_args {
    _ = try proto.readStructBegin()
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")

    return Apply_sha1_args(data: data)
  }

}



fileprivate final class Apply_sha1_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_sha1_result, rhs: Apply_sha1_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_sha1_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_sha1_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_sha1_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_sha1_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_sha1_result(success: success)
  }

}



fileprivate final class Apply_sha512_args {

  fileprivate var data: Data


  fileprivate init(data: Data) {
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_sha512_args, rhs: Apply_sha512_args) -> Bool {
  return
    (lhs.data == rhs.data)
}

extension Apply_sha512_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(data)
  }

}

extension Apply_sha512_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, ]
  }

  fileprivate static var structName: String { return "Apply_sha512_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_sha512_args {
    _ = try proto.readStructBegin()
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")

    return Apply_sha512_args(data: data)
  }

}



fileprivate final class Apply_sha512_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_sha512_result, rhs: Apply_sha512_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_sha512_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_sha512_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_sha512_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_sha512_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_sha512_result(success: success)
  }

}



fileprivate final class Apply_ripemd160_args {

  fileprivate var data: Data


  fileprivate init(data: Data) {
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_ripemd160_args, rhs: Apply_ripemd160_args) -> Bool {
  return
    (lhs.data == rhs.data)
}

extension Apply_ripemd160_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(data)
  }

}

extension Apply_ripemd160_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, ]
  }

  fileprivate static var structName: String { return "Apply_ripemd160_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_ripemd160_args {
    _ = try proto.readStructBegin()
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")

    return Apply_ripemd160_args(data: data)
  }

}



fileprivate final class Apply_ripemd160_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_ripemd160_result, rhs: Apply_ripemd160_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_ripemd160_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_ripemd160_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_ripemd160_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_ripemd160_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_ripemd160_result(success: success)
  }

}



fileprivate final class Apply_recover_key_args {

  fileprivate var digest: Data

  fileprivate var sig: Data


  fileprivate init(digest: Data, sig: Data) {
    self.digest = digest
    self.sig = sig
  }

}

fileprivate func ==(lhs: Apply_recover_key_args, rhs: Apply_recover_key_args) -> Bool {
  return
    (lhs.digest == rhs.digest) &&
    (lhs.sig == rhs.sig)
}

extension Apply_recover_key_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(digest)
    hasher.combine(sig)
  }

}

extension Apply_recover_key_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["digest": 1, "sig": 2, ]
  }

  fileprivate static var structName: String { return "Apply_recover_key_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_recover_key_args {
    _ = try proto.readStructBegin()
    var digest: Data!
    var sig: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           digest = try Data.read(from: proto)
        case (2, .string):           sig = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(digest, named: "digest")
    try proto.validateValue(sig, named: "sig")

    return Apply_recover_key_args(digest: digest, sig: sig)
  }

}



fileprivate final class Apply_recover_key_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_recover_key_result, rhs: Apply_recover_key_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_recover_key_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_recover_key_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_recover_key_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_recover_key_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_recover_key_result(success: success)
  }

}



fileprivate final class Apply_assert_recover_key_args {

  fileprivate var digest: Data

  fileprivate var sig: Data

  fileprivate var pub: Data


  fileprivate init(digest: Data, sig: Data, pub: Data) {
    self.digest = digest
    self.sig = sig
    self.pub = pub
  }

}

fileprivate func ==(lhs: Apply_assert_recover_key_args, rhs: Apply_assert_recover_key_args) -> Bool {
  return
    (lhs.digest == rhs.digest) &&
    (lhs.sig == rhs.sig) &&
    (lhs.pub == rhs.pub)
}

extension Apply_assert_recover_key_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(digest)
    hasher.combine(sig)
    hasher.combine(pub)
  }

}

extension Apply_assert_recover_key_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["digest": 1, "sig": 2, "pub": 3, ]
  }

  fileprivate static var structName: String { return "Apply_assert_recover_key_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_assert_recover_key_args {
    _ = try proto.readStructBegin()
    var digest: Data!
    var sig: Data!
    var pub: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           digest = try Data.read(from: proto)
        case (2, .string):           sig = try Data.read(from: proto)
        case (3, .string):           pub = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(digest, named: "digest")
    try proto.validateValue(sig, named: "sig")
    try proto.validateValue(pub, named: "pub")

    return Apply_assert_recover_key_args(digest: digest, sig: sig, pub: pub)
  }

}



fileprivate final class Apply_assert_recover_key_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_assert_recover_key_result, rhs: Apply_assert_recover_key_result) -> Bool {
  return true
}

extension Apply_assert_recover_key_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_assert_recover_key_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_assert_recover_key_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_assert_recover_key_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_assert_recover_key_result()
  }

}



fileprivate final class Apply_send_deferred_args {

  fileprivate var sender_id: Data

  fileprivate var payer: Uint64

  fileprivate var serialized_transaction: Data

  fileprivate var replace_existing: Int32


  fileprivate init(sender_id: Data, payer: Uint64, serialized_transaction: Data, replace_existing: Int32) {
    self.sender_id = sender_id
    self.payer = payer
    self.serialized_transaction = serialized_transaction
    self.replace_existing = replace_existing
  }

}

fileprivate func ==(lhs: Apply_send_deferred_args, rhs: Apply_send_deferred_args) -> Bool {
  return
    (lhs.sender_id == rhs.sender_id) &&
    (lhs.payer == rhs.payer) &&
    (lhs.serialized_transaction == rhs.serialized_transaction) &&
    (lhs.replace_existing == rhs.replace_existing)
}

extension Apply_send_deferred_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(sender_id)
    hasher.combine(payer)
    hasher.combine(serialized_transaction)
    hasher.combine(replace_existing)
  }

}

extension Apply_send_deferred_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sender_id": 1, "payer": 2, "serialized_transaction": 3, "replace_existing": 4, ]
  }

  fileprivate static var structName: String { return "Apply_send_deferred_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_send_deferred_args {
    _ = try proto.readStructBegin()
    var sender_id: Data!
    var payer: Uint64!
    var serialized_transaction: Data!
    var replace_existing: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           sender_id = try Data.read(from: proto)
        case (2, .struct):           payer = try Uint64.read(from: proto)
        case (3, .string):           serialized_transaction = try Data.read(from: proto)
        case (4, .i32):             replace_existing = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sender_id, named: "sender_id")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(serialized_transaction, named: "serialized_transaction")
    try proto.validateValue(replace_existing, named: "replace_existing")

    return Apply_send_deferred_args(sender_id: sender_id, payer: payer, serialized_transaction: serialized_transaction, replace_existing: replace_existing)
  }

}



fileprivate final class Apply_send_deferred_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_send_deferred_result, rhs: Apply_send_deferred_result) -> Bool {
  return true
}

extension Apply_send_deferred_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_send_deferred_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_send_deferred_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_send_deferred_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_send_deferred_result()
  }

}



fileprivate final class Apply_cancel_deferred_args {

  fileprivate var sender_id: Data


  fileprivate init(sender_id: Data) {
    self.sender_id = sender_id
  }

}

fileprivate func ==(lhs: Apply_cancel_deferred_args, rhs: Apply_cancel_deferred_args) -> Bool {
  return
    (lhs.sender_id == rhs.sender_id)
}

extension Apply_cancel_deferred_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(sender_id)
  }

}

extension Apply_cancel_deferred_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sender_id": 1, ]
  }

  fileprivate static var structName: String { return "Apply_cancel_deferred_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_cancel_deferred_args {
    _ = try proto.readStructBegin()
    var sender_id: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           sender_id = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sender_id, named: "sender_id")

    return Apply_cancel_deferred_args(sender_id: sender_id)
  }

}



fileprivate final class Apply_cancel_deferred_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_cancel_deferred_result, rhs: Apply_cancel_deferred_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_cancel_deferred_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_cancel_deferred_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_cancel_deferred_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_cancel_deferred_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_cancel_deferred_result(success: success)
  }

}



fileprivate final class Apply_read_transaction_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_read_transaction_args, rhs: Apply_read_transaction_args) -> Bool {
  return true
}

extension Apply_read_transaction_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_read_transaction_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_read_transaction_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_read_transaction_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_read_transaction_args()
  }

}



fileprivate final class Apply_read_transaction_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_read_transaction_result, rhs: Apply_read_transaction_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_read_transaction_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_read_transaction_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_read_transaction_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_read_transaction_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_read_transaction_result(success: success)
  }

}



fileprivate final class Apply_transaction_size_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_transaction_size_args, rhs: Apply_transaction_size_args) -> Bool {
  return true
}

extension Apply_transaction_size_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_transaction_size_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_transaction_size_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_transaction_size_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_transaction_size_args()
  }

}



fileprivate final class Apply_transaction_size_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_transaction_size_result, rhs: Apply_transaction_size_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_transaction_size_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_transaction_size_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_transaction_size_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_transaction_size_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_transaction_size_result(success: success)
  }

}



fileprivate final class Apply_tapos_block_num_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_tapos_block_num_args, rhs: Apply_tapos_block_num_args) -> Bool {
  return true
}

extension Apply_tapos_block_num_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_tapos_block_num_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_tapos_block_num_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_tapos_block_num_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_tapos_block_num_args()
  }

}



fileprivate final class Apply_tapos_block_num_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_tapos_block_num_result, rhs: Apply_tapos_block_num_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_tapos_block_num_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_tapos_block_num_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_tapos_block_num_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_tapos_block_num_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_tapos_block_num_result(success: success)
  }

}



fileprivate final class Apply_tapos_block_prefix_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_tapos_block_prefix_args, rhs: Apply_tapos_block_prefix_args) -> Bool {
  return true
}

extension Apply_tapos_block_prefix_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_tapos_block_prefix_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_tapos_block_prefix_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_tapos_block_prefix_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_tapos_block_prefix_args()
  }

}



fileprivate final class Apply_tapos_block_prefix_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_tapos_block_prefix_result, rhs: Apply_tapos_block_prefix_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_tapos_block_prefix_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_tapos_block_prefix_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_tapos_block_prefix_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_tapos_block_prefix_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_tapos_block_prefix_result(success: success)
  }

}



fileprivate final class Apply_expiration_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_expiration_args, rhs: Apply_expiration_args) -> Bool {
  return true
}

extension Apply_expiration_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_expiration_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_expiration_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_expiration_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_expiration_args()
  }

}



fileprivate final class Apply_expiration_result {

  fileprivate var success: Int64?


  fileprivate init() { }
  fileprivate init(success: Int64?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_expiration_result, rhs: Apply_expiration_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_expiration_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_expiration_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_expiration_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_expiration_result {
    _ = try proto.readStructBegin()
    var success: Int64?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_expiration_result(success: success)
  }

}



fileprivate final class Apply_get_action_args {

  fileprivate var _type: Int32

  fileprivate var index: Int32


  fileprivate init(_type: Int32, index: Int32) {
    self._type = _type
    self.index = index
  }

}

fileprivate func ==(lhs: Apply_get_action_args, rhs: Apply_get_action_args) -> Bool {
  return
    (lhs._type == rhs._type) &&
    (lhs.index == rhs.index)
}

extension Apply_get_action_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(_type)
    hasher.combine(index)
  }

}

extension Apply_get_action_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["_type": 1, "index": 2, ]
  }

  fileprivate static var structName: String { return "Apply_get_action_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_action_args {
    _ = try proto.readStructBegin()
    var _type: Int32!
    var index: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             _type = try Int32.read(from: proto)
        case (2, .i32):             index = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(_type, named: "_type")
    try proto.validateValue(index, named: "index")

    return Apply_get_action_args(_type: _type, index: index)
  }

}



fileprivate final class Apply_get_action_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_get_action_result, rhs: Apply_get_action_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_get_action_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_get_action_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_get_action_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_action_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_action_result(success: success)
  }

}



fileprivate final class Apply_get_context_free_data_args {

  fileprivate var index: Int32


  fileprivate init(index: Int32) {
    self.index = index
  }

}

fileprivate func ==(lhs: Apply_get_context_free_data_args, rhs: Apply_get_context_free_data_args) -> Bool {
  return
    (lhs.index == rhs.index)
}

extension Apply_get_context_free_data_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(index)
  }

}

extension Apply_get_context_free_data_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["index": 1, ]
  }

  fileprivate static var structName: String { return "Apply_get_context_free_data_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_context_free_data_args {
    _ = try proto.readStructBegin()
    var index: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             index = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(index, named: "index")

    return Apply_get_context_free_data_args(index: index)
  }

}



fileprivate final class Apply_get_context_free_data_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_get_context_free_data_result, rhs: Apply_get_context_free_data_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_get_context_free_data_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_get_context_free_data_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_get_context_free_data_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_get_context_free_data_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_get_context_free_data_result(success: success)
  }

}



fileprivate final class Apply_db_store_i64_args {

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var payer: Uint64

  fileprivate var id: Uint64

  fileprivate var data: Data


  fileprivate init(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Data) {
    self.scope = scope
    self.table = table
    self.payer = payer
    self.id = id
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_db_store_i64_args, rhs: Apply_db_store_i64_args) -> Bool {
  return
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.payer == rhs.payer) &&
    (lhs.id == rhs.id) &&
    (lhs.data == rhs.data)
}

extension Apply_db_store_i64_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(payer)
    hasher.combine(id)
    hasher.combine(data)
  }

}

extension Apply_db_store_i64_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["scope": 1, "table": 2, "payer": 3, "id": 4, "data": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_store_i64_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_store_i64_args {
    _ = try proto.readStructBegin()
    var scope: Uint64!
    var table: Uint64!
    var payer: Uint64!
    var id: Uint64!
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           scope = try Uint64.read(from: proto)
        case (2, .struct):           table = try Uint64.read(from: proto)
        case (3, .struct):           payer = try Uint64.read(from: proto)
        case (4, .struct):           id = try Uint64.read(from: proto)
        case (5, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(id, named: "id")
    try proto.validateValue(data, named: "data")

    return Apply_db_store_i64_args(scope: scope, table: table, payer: payer, id: id, data: data)
  }

}



fileprivate final class Apply_db_store_i64_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_store_i64_result, rhs: Apply_db_store_i64_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_store_i64_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_store_i64_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_store_i64_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_store_i64_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_store_i64_result(success: success)
  }

}



fileprivate final class Apply_db_update_i64_args {

  fileprivate var iterator: Int32

  fileprivate var payer: Uint64

  fileprivate var data: Data


  fileprivate init(iterator: Int32, payer: Uint64, data: Data) {
    self.iterator = iterator
    self.payer = payer
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_db_update_i64_args, rhs: Apply_db_update_i64_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.payer == rhs.payer) &&
    (lhs.data == rhs.data)
}

extension Apply_db_update_i64_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(payer)
    hasher.combine(data)
  }

}

extension Apply_db_update_i64_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, "payer": 2, "data": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_update_i64_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_update_i64_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var payer: Uint64!
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .struct):           payer = try Uint64.read(from: proto)
        case (3, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(data, named: "data")

    return Apply_db_update_i64_args(iterator: iterator, payer: payer, data: data)
  }

}



fileprivate final class Apply_db_update_i64_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_update_i64_result, rhs: Apply_db_update_i64_result) -> Bool {
  return true
}

extension Apply_db_update_i64_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_update_i64_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_update_i64_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_update_i64_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_update_i64_result()
  }

}



fileprivate final class Apply_db_remove_i64_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_remove_i64_args, rhs: Apply_db_remove_i64_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_remove_i64_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_remove_i64_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_remove_i64_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_remove_i64_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_remove_i64_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_remove_i64_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_remove_i64_result, rhs: Apply_db_remove_i64_result) -> Bool {
  return true
}

extension Apply_db_remove_i64_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_remove_i64_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_remove_i64_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_remove_i64_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_remove_i64_result()
  }

}



fileprivate final class Apply_db_get_i64_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_get_i64_args, rhs: Apply_db_get_i64_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_get_i64_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_get_i64_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_get_i64_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_get_i64_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_get_i64_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_get_i64_result {

  fileprivate var success: Data?


  fileprivate init() { }
  fileprivate init(success: Data?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_get_i64_result, rhs: Apply_db_get_i64_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_get_i64_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_get_i64_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_get_i64_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_get_i64_result {
    _ = try proto.readStructBegin()
    var success: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_get_i64_result(success: success)
  }

}



fileprivate final class Apply_db_next_i64_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_next_i64_args, rhs: Apply_db_next_i64_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_next_i64_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_next_i64_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_next_i64_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_next_i64_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_next_i64_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_next_i64_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_next_i64_result, rhs: Apply_db_next_i64_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_next_i64_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_next_i64_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_next_i64_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_next_i64_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_next_i64_result(success: success)
  }

}



fileprivate final class Apply_db_previous_i64_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_previous_i64_args, rhs: Apply_db_previous_i64_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_previous_i64_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_previous_i64_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_previous_i64_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_previous_i64_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_previous_i64_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_previous_i64_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_previous_i64_result, rhs: Apply_db_previous_i64_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_previous_i64_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_previous_i64_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_previous_i64_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_previous_i64_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_previous_i64_result(success: success)
  }

}



fileprivate final class Apply_db_find_i64_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var id: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, id: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.id = id
  }

}

fileprivate func ==(lhs: Apply_db_find_i64_args, rhs: Apply_db_find_i64_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.id == rhs.id)
}

extension Apply_db_find_i64_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(id)
  }

}

extension Apply_db_find_i64_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "id": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_find_i64_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_find_i64_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var id: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           id = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(id, named: "id")

    return Apply_db_find_i64_args(code: code, scope: scope, table: table, id: id)
  }

}



fileprivate final class Apply_db_find_i64_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_find_i64_result, rhs: Apply_db_find_i64_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_find_i64_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_find_i64_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_find_i64_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_find_i64_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_find_i64_result(success: success)
  }

}



fileprivate final class Apply_db_lowerbound_i64_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var id: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, id: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.id = id
  }

}

fileprivate func ==(lhs: Apply_db_lowerbound_i64_args, rhs: Apply_db_lowerbound_i64_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.id == rhs.id)
}

extension Apply_db_lowerbound_i64_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(id)
  }

}

extension Apply_db_lowerbound_i64_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "id": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_lowerbound_i64_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_lowerbound_i64_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var id: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           id = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(id, named: "id")

    return Apply_db_lowerbound_i64_args(code: code, scope: scope, table: table, id: id)
  }

}



fileprivate final class Apply_db_lowerbound_i64_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_lowerbound_i64_result, rhs: Apply_db_lowerbound_i64_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_lowerbound_i64_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_lowerbound_i64_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_lowerbound_i64_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_lowerbound_i64_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_lowerbound_i64_result(success: success)
  }

}



fileprivate final class Apply_db_upperbound_i64_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var id: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, id: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.id = id
  }

}

fileprivate func ==(lhs: Apply_db_upperbound_i64_args, rhs: Apply_db_upperbound_i64_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.id == rhs.id)
}

extension Apply_db_upperbound_i64_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(id)
  }

}

extension Apply_db_upperbound_i64_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "id": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_upperbound_i64_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_upperbound_i64_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var id: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           id = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(id, named: "id")

    return Apply_db_upperbound_i64_args(code: code, scope: scope, table: table, id: id)
  }

}



fileprivate final class Apply_db_upperbound_i64_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_upperbound_i64_result, rhs: Apply_db_upperbound_i64_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_upperbound_i64_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_upperbound_i64_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_upperbound_i64_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_upperbound_i64_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_upperbound_i64_result(success: success)
  }

}



fileprivate final class Apply_db_end_i64_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
  }

}

fileprivate func ==(lhs: Apply_db_end_i64_args, rhs: Apply_db_end_i64_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table)
}

extension Apply_db_end_i64_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
  }

}

extension Apply_db_end_i64_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_end_i64_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_end_i64_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")

    return Apply_db_end_i64_args(code: code, scope: scope, table: table)
  }

}



fileprivate final class Apply_db_end_i64_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_end_i64_result, rhs: Apply_db_end_i64_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_end_i64_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_end_i64_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_end_i64_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_end_i64_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_end_i64_result(success: success)
  }

}



fileprivate final class Apply_db_idx64_store_args {

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var payer: Uint64

  fileprivate var id: Uint64

  fileprivate var secondary: Uint64


  fileprivate init(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Uint64) {
    self.scope = scope
    self.table = table
    self.payer = payer
    self.id = id
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx64_store_args, rhs: Apply_db_idx64_store_args) -> Bool {
  return
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.payer == rhs.payer) &&
    (lhs.id == rhs.id) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx64_store_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(payer)
    hasher.combine(id)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx64_store_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["scope": 1, "table": 2, "payer": 3, "id": 4, "secondary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_store_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_store_args {
    _ = try proto.readStructBegin()
    var scope: Uint64!
    var table: Uint64!
    var payer: Uint64!
    var id: Uint64!
    var secondary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           scope = try Uint64.read(from: proto)
        case (2, .struct):           table = try Uint64.read(from: proto)
        case (3, .struct):           payer = try Uint64.read(from: proto)
        case (4, .struct):           id = try Uint64.read(from: proto)
        case (5, .struct):           secondary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(id, named: "id")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx64_store_args(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx64_store_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx64_store_result, rhs: Apply_db_idx64_store_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx64_store_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx64_store_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_store_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_store_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx64_store_result(success: success)
  }

}



fileprivate final class Apply_db_idx64_update_args {

  fileprivate var iterator: Int32

  fileprivate var payer: Uint64

  fileprivate var secondary: Uint64


  fileprivate init(iterator: Int32, payer: Uint64, secondary: Uint64) {
    self.iterator = iterator
    self.payer = payer
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx64_update_args, rhs: Apply_db_idx64_update_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.payer == rhs.payer) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx64_update_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(payer)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx64_update_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, "payer": 2, "secondary": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_update_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_update_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var payer: Uint64!
    var secondary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .struct):           payer = try Uint64.read(from: proto)
        case (3, .struct):           secondary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx64_update_args(iterator: iterator, payer: payer, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx64_update_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_idx64_update_result, rhs: Apply_db_idx64_update_result) -> Bool {
  return true
}

extension Apply_db_idx64_update_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_idx64_update_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_update_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_update_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx64_update_result()
  }

}



fileprivate final class Apply_db_idx64_remove_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx64_remove_args, rhs: Apply_db_idx64_remove_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx64_remove_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx64_remove_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_remove_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_remove_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx64_remove_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx64_remove_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_idx64_remove_result, rhs: Apply_db_idx64_remove_result) -> Bool {
  return true
}

extension Apply_db_idx64_remove_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_idx64_remove_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_remove_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_remove_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx64_remove_result()
  }

}



fileprivate final class Apply_db_idx64_next_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx64_next_args, rhs: Apply_db_idx64_next_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx64_next_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx64_next_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_next_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_next_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx64_next_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx64_next_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx64_next_result, rhs: Apply_db_idx64_next_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx64_next_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx64_next_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_next_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_next_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx64_next_result(success: success)
  }

}



fileprivate final class Apply_db_idx64_previous_args {

  fileprivate var iteratory: Int32


  fileprivate init(iteratory: Int32) {
    self.iteratory = iteratory
  }

}

fileprivate func ==(lhs: Apply_db_idx64_previous_args, rhs: Apply_db_idx64_previous_args) -> Bool {
  return
    (lhs.iteratory == rhs.iteratory)
}

extension Apply_db_idx64_previous_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iteratory)
  }

}

extension Apply_db_idx64_previous_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iteratory": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_previous_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_previous_args {
    _ = try proto.readStructBegin()
    var iteratory: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iteratory = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iteratory, named: "iteratory")

    return Apply_db_idx64_previous_args(iteratory: iteratory)
  }

}



fileprivate final class Apply_db_idx64_previous_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx64_previous_result, rhs: Apply_db_idx64_previous_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx64_previous_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx64_previous_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_previous_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_previous_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx64_previous_result(success: success)
  }

}



fileprivate final class Apply_db_idx64_find_primary_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx64_find_primary_args, rhs: Apply_db_idx64_find_primary_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx64_find_primary_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(primary)
  }

}

extension Apply_db_idx64_find_primary_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "primary": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_find_primary_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_find_primary_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx64_find_primary_args(code: code, scope: scope, table: table, primary: primary)
  }

}



fileprivate final class Apply_db_idx64_find_primary_result {

  fileprivate var success: FindPrimaryReturn?


  fileprivate init() { }
  fileprivate init(success: FindPrimaryReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx64_find_primary_result, rhs: Apply_db_idx64_find_primary_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx64_find_primary_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx64_find_primary_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_find_primary_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_find_primary_result {
    _ = try proto.readStructBegin()
    var success: FindPrimaryReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FindPrimaryReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx64_find_primary_result(success: success)
  }

}



fileprivate final class Apply_db_idx64_find_secondary_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx64_find_secondary_args, rhs: Apply_db_idx64_find_secondary_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx64_find_secondary_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx64_find_secondary_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_find_secondary_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_find_secondary_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           secondary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx64_find_secondary_args(code: code, scope: scope, table: table, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx64_find_secondary_result {

  fileprivate var success: FindSecondaryReturn?


  fileprivate init() { }
  fileprivate init(success: FindSecondaryReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx64_find_secondary_result, rhs: Apply_db_idx64_find_secondary_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx64_find_secondary_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx64_find_secondary_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_find_secondary_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_find_secondary_result {
    _ = try proto.readStructBegin()
    var success: FindSecondaryReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FindSecondaryReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx64_find_secondary_result(success: success)
  }

}



fileprivate final class Apply_db_idx64_lowerbound_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Uint64

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx64_lowerbound_args, rhs: Apply_db_idx64_lowerbound_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx64_lowerbound_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
    hasher.combine(primary)
  }

}

extension Apply_db_idx64_lowerbound_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, "primary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_lowerbound_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_lowerbound_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Uint64!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           secondary = try Uint64.read(from: proto)
        case (5, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx64_lowerbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
  }

}



fileprivate final class Apply_db_idx64_lowerbound_result {

  fileprivate var success: LowerBoundUpperBoundReturn?


  fileprivate init() { }
  fileprivate init(success: LowerBoundUpperBoundReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx64_lowerbound_result, rhs: Apply_db_idx64_lowerbound_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx64_lowerbound_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx64_lowerbound_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_lowerbound_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_lowerbound_result {
    _ = try proto.readStructBegin()
    var success: LowerBoundUpperBoundReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LowerBoundUpperBoundReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx64_lowerbound_result(success: success)
  }

}



fileprivate final class Apply_db_idx64_upperbound_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Uint64

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx64_upperbound_args, rhs: Apply_db_idx64_upperbound_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx64_upperbound_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
    hasher.combine(primary)
  }

}

extension Apply_db_idx64_upperbound_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, "primary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_upperbound_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_upperbound_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Uint64!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           secondary = try Uint64.read(from: proto)
        case (5, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx64_upperbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
  }

}



fileprivate final class Apply_db_idx64_upperbound_result {

  fileprivate var success: LowerBoundUpperBoundReturn?


  fileprivate init() { }
  fileprivate init(success: LowerBoundUpperBoundReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx64_upperbound_result, rhs: Apply_db_idx64_upperbound_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx64_upperbound_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx64_upperbound_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_upperbound_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_upperbound_result {
    _ = try proto.readStructBegin()
    var success: LowerBoundUpperBoundReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LowerBoundUpperBoundReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx64_upperbound_result(success: success)
  }

}



fileprivate final class Apply_db_idx64_end_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
  }

}

fileprivate func ==(lhs: Apply_db_idx64_end_args, rhs: Apply_db_idx64_end_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table)
}

extension Apply_db_idx64_end_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
  }

}

extension Apply_db_idx64_end_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_end_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_end_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")

    return Apply_db_idx64_end_args(code: code, scope: scope, table: table)
  }

}



fileprivate final class Apply_db_idx64_end_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx64_end_result, rhs: Apply_db_idx64_end_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx64_end_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx64_end_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx64_end_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx64_end_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx64_end_result(success: success)
  }

}



fileprivate final class Apply_db_idx128_store_args {

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var payer: Uint64

  fileprivate var id: Uint64

  fileprivate var secondary: Data


  fileprivate init(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Data) {
    self.scope = scope
    self.table = table
    self.payer = payer
    self.id = id
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx128_store_args, rhs: Apply_db_idx128_store_args) -> Bool {
  return
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.payer == rhs.payer) &&
    (lhs.id == rhs.id) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx128_store_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(payer)
    hasher.combine(id)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx128_store_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["scope": 1, "table": 2, "payer": 3, "id": 4, "secondary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_store_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_store_args {
    _ = try proto.readStructBegin()
    var scope: Uint64!
    var table: Uint64!
    var payer: Uint64!
    var id: Uint64!
    var secondary: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           scope = try Uint64.read(from: proto)
        case (2, .struct):           table = try Uint64.read(from: proto)
        case (3, .struct):           payer = try Uint64.read(from: proto)
        case (4, .struct):           id = try Uint64.read(from: proto)
        case (5, .string):           secondary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(id, named: "id")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx128_store_args(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx128_store_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx128_store_result, rhs: Apply_db_idx128_store_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx128_store_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx128_store_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_store_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_store_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx128_store_result(success: success)
  }

}



fileprivate final class Apply_db_idx128_update_args {

  fileprivate var iterator: Int32

  fileprivate var payer: Uint64

  fileprivate var secondary: Data


  fileprivate init(iterator: Int32, payer: Uint64, secondary: Data) {
    self.iterator = iterator
    self.payer = payer
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx128_update_args, rhs: Apply_db_idx128_update_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.payer == rhs.payer) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx128_update_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(payer)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx128_update_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, "payer": 2, "secondary": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_update_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_update_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var payer: Uint64!
    var secondary: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .struct):           payer = try Uint64.read(from: proto)
        case (3, .string):           secondary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx128_update_args(iterator: iterator, payer: payer, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx128_update_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_idx128_update_result, rhs: Apply_db_idx128_update_result) -> Bool {
  return true
}

extension Apply_db_idx128_update_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_idx128_update_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_update_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_update_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx128_update_result()
  }

}



fileprivate final class Apply_db_idx128_remove_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx128_remove_args, rhs: Apply_db_idx128_remove_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx128_remove_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx128_remove_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_remove_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_remove_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx128_remove_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx128_remove_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_idx128_remove_result, rhs: Apply_db_idx128_remove_result) -> Bool {
  return true
}

extension Apply_db_idx128_remove_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_idx128_remove_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_remove_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_remove_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx128_remove_result()
  }

}



fileprivate final class Apply_db_idx128_next_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx128_next_args, rhs: Apply_db_idx128_next_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx128_next_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx128_next_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_next_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_next_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx128_next_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx128_next_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx128_next_result, rhs: Apply_db_idx128_next_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx128_next_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx128_next_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_next_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_next_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx128_next_result(success: success)
  }

}



fileprivate final class Apply_db_idx128_previous_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx128_previous_args, rhs: Apply_db_idx128_previous_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx128_previous_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx128_previous_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_previous_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_previous_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx128_previous_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx128_previous_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx128_previous_result, rhs: Apply_db_idx128_previous_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx128_previous_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx128_previous_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_previous_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_previous_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx128_previous_result(success: success)
  }

}



fileprivate final class Apply_db_idx128_find_primary_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx128_find_primary_args, rhs: Apply_db_idx128_find_primary_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx128_find_primary_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(primary)
  }

}

extension Apply_db_idx128_find_primary_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "primary": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_find_primary_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_find_primary_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx128_find_primary_args(code: code, scope: scope, table: table, primary: primary)
  }

}



fileprivate final class Apply_db_idx128_find_primary_result {

  fileprivate var success: FindPrimaryReturn?


  fileprivate init() { }
  fileprivate init(success: FindPrimaryReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx128_find_primary_result, rhs: Apply_db_idx128_find_primary_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx128_find_primary_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx128_find_primary_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_find_primary_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_find_primary_result {
    _ = try proto.readStructBegin()
    var success: FindPrimaryReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FindPrimaryReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx128_find_primary_result(success: success)
  }

}



fileprivate final class Apply_db_idx128_find_secondary_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Data


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Data) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx128_find_secondary_args, rhs: Apply_db_idx128_find_secondary_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx128_find_secondary_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx128_find_secondary_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_find_secondary_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_find_secondary_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           secondary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx128_find_secondary_args(code: code, scope: scope, table: table, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx128_find_secondary_result {

  fileprivate var success: FindSecondaryReturn?


  fileprivate init() { }
  fileprivate init(success: FindSecondaryReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx128_find_secondary_result, rhs: Apply_db_idx128_find_secondary_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx128_find_secondary_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx128_find_secondary_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_find_secondary_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_find_secondary_result {
    _ = try proto.readStructBegin()
    var success: FindSecondaryReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FindSecondaryReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx128_find_secondary_result(success: success)
  }

}



fileprivate final class Apply_db_idx128_lowerbound_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Data

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx128_lowerbound_args, rhs: Apply_db_idx128_lowerbound_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx128_lowerbound_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
    hasher.combine(primary)
  }

}

extension Apply_db_idx128_lowerbound_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, "primary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_lowerbound_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_lowerbound_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Data!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           secondary = try Data.read(from: proto)
        case (5, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx128_lowerbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
  }

}



fileprivate final class Apply_db_idx128_lowerbound_result {

  fileprivate var success: LowerBoundUpperBoundReturn?


  fileprivate init() { }
  fileprivate init(success: LowerBoundUpperBoundReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx128_lowerbound_result, rhs: Apply_db_idx128_lowerbound_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx128_lowerbound_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx128_lowerbound_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_lowerbound_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_lowerbound_result {
    _ = try proto.readStructBegin()
    var success: LowerBoundUpperBoundReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LowerBoundUpperBoundReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx128_lowerbound_result(success: success)
  }

}



fileprivate final class Apply_db_idx128_upperbound_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Data

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx128_upperbound_args, rhs: Apply_db_idx128_upperbound_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx128_upperbound_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
    hasher.combine(primary)
  }

}

extension Apply_db_idx128_upperbound_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, "primary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_upperbound_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_upperbound_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Data!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           secondary = try Data.read(from: proto)
        case (5, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx128_upperbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
  }

}



fileprivate final class Apply_db_idx128_upperbound_result {

  fileprivate var success: LowerBoundUpperBoundReturn?


  fileprivate init() { }
  fileprivate init(success: LowerBoundUpperBoundReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx128_upperbound_result, rhs: Apply_db_idx128_upperbound_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx128_upperbound_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx128_upperbound_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_upperbound_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_upperbound_result {
    _ = try proto.readStructBegin()
    var success: LowerBoundUpperBoundReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LowerBoundUpperBoundReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx128_upperbound_result(success: success)
  }

}



fileprivate final class Apply_db_idx128_end_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
  }

}

fileprivate func ==(lhs: Apply_db_idx128_end_args, rhs: Apply_db_idx128_end_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table)
}

extension Apply_db_idx128_end_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
  }

}

extension Apply_db_idx128_end_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_end_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_end_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")

    return Apply_db_idx128_end_args(code: code, scope: scope, table: table)
  }

}



fileprivate final class Apply_db_idx128_end_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx128_end_result, rhs: Apply_db_idx128_end_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx128_end_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx128_end_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx128_end_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx128_end_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx128_end_result(success: success)
  }

}



fileprivate final class Apply_db_idx256_store_args {

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var payer: Uint64

  fileprivate var id: Uint64

  fileprivate var data: Data


  fileprivate init(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Data) {
    self.scope = scope
    self.table = table
    self.payer = payer
    self.id = id
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_db_idx256_store_args, rhs: Apply_db_idx256_store_args) -> Bool {
  return
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.payer == rhs.payer) &&
    (lhs.id == rhs.id) &&
    (lhs.data == rhs.data)
}

extension Apply_db_idx256_store_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(payer)
    hasher.combine(id)
    hasher.combine(data)
  }

}

extension Apply_db_idx256_store_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["scope": 1, "table": 2, "payer": 3, "id": 4, "data": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_store_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_store_args {
    _ = try proto.readStructBegin()
    var scope: Uint64!
    var table: Uint64!
    var payer: Uint64!
    var id: Uint64!
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           scope = try Uint64.read(from: proto)
        case (2, .struct):           table = try Uint64.read(from: proto)
        case (3, .struct):           payer = try Uint64.read(from: proto)
        case (4, .struct):           id = try Uint64.read(from: proto)
        case (5, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(id, named: "id")
    try proto.validateValue(data, named: "data")

    return Apply_db_idx256_store_args(scope: scope, table: table, payer: payer, id: id, data: data)
  }

}



fileprivate final class Apply_db_idx256_store_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx256_store_result, rhs: Apply_db_idx256_store_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx256_store_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx256_store_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_store_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_store_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx256_store_result(success: success)
  }

}



fileprivate final class Apply_db_idx256_update_args {

  fileprivate var iterator: Int32

  fileprivate var payer: Uint64

  fileprivate var data: Data


  fileprivate init(iterator: Int32, payer: Uint64, data: Data) {
    self.iterator = iterator
    self.payer = payer
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_db_idx256_update_args, rhs: Apply_db_idx256_update_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.payer == rhs.payer) &&
    (lhs.data == rhs.data)
}

extension Apply_db_idx256_update_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(payer)
    hasher.combine(data)
  }

}

extension Apply_db_idx256_update_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, "payer": 2, "data": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_update_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_update_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var payer: Uint64!
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .struct):           payer = try Uint64.read(from: proto)
        case (3, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(data, named: "data")

    return Apply_db_idx256_update_args(iterator: iterator, payer: payer, data: data)
  }

}



fileprivate final class Apply_db_idx256_update_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_idx256_update_result, rhs: Apply_db_idx256_update_result) -> Bool {
  return true
}

extension Apply_db_idx256_update_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_idx256_update_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_update_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_update_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx256_update_result()
  }

}



fileprivate final class Apply_db_idx256_remove_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx256_remove_args, rhs: Apply_db_idx256_remove_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx256_remove_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx256_remove_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_remove_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_remove_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx256_remove_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx256_remove_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_idx256_remove_result, rhs: Apply_db_idx256_remove_result) -> Bool {
  return true
}

extension Apply_db_idx256_remove_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_idx256_remove_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_remove_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_remove_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx256_remove_result()
  }

}



fileprivate final class Apply_db_idx256_next_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx256_next_args, rhs: Apply_db_idx256_next_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx256_next_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx256_next_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_next_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_next_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx256_next_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx256_next_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx256_next_result, rhs: Apply_db_idx256_next_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx256_next_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx256_next_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_next_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_next_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx256_next_result(success: success)
  }

}



fileprivate final class Apply_db_idx256_previous_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx256_previous_args, rhs: Apply_db_idx256_previous_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx256_previous_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx256_previous_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_previous_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_previous_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx256_previous_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx256_previous_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx256_previous_result, rhs: Apply_db_idx256_previous_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx256_previous_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx256_previous_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_previous_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_previous_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx256_previous_result(success: success)
  }

}



fileprivate final class Apply_db_idx256_find_primary_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx256_find_primary_args, rhs: Apply_db_idx256_find_primary_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx256_find_primary_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(primary)
  }

}

extension Apply_db_idx256_find_primary_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "primary": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_find_primary_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_find_primary_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx256_find_primary_args(code: code, scope: scope, table: table, primary: primary)
  }

}



fileprivate final class Apply_db_idx256_find_primary_result {

  fileprivate var success: FindPrimaryReturn?


  fileprivate init() { }
  fileprivate init(success: FindPrimaryReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx256_find_primary_result, rhs: Apply_db_idx256_find_primary_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx256_find_primary_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx256_find_primary_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_find_primary_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_find_primary_result {
    _ = try proto.readStructBegin()
    var success: FindPrimaryReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FindPrimaryReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx256_find_primary_result(success: success)
  }

}



fileprivate final class Apply_db_idx256_find_secondary_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var data: Data


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, data: Data) {
    self.code = code
    self.scope = scope
    self.table = table
    self.data = data
  }

}

fileprivate func ==(lhs: Apply_db_idx256_find_secondary_args, rhs: Apply_db_idx256_find_secondary_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.data == rhs.data)
}

extension Apply_db_idx256_find_secondary_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(data)
  }

}

extension Apply_db_idx256_find_secondary_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "data": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_find_secondary_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_find_secondary_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(data, named: "data")

    return Apply_db_idx256_find_secondary_args(code: code, scope: scope, table: table, data: data)
  }

}



fileprivate final class Apply_db_idx256_find_secondary_result {

  fileprivate var success: FindSecondaryReturn?


  fileprivate init() { }
  fileprivate init(success: FindSecondaryReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx256_find_secondary_result, rhs: Apply_db_idx256_find_secondary_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx256_find_secondary_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx256_find_secondary_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_find_secondary_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_find_secondary_result {
    _ = try proto.readStructBegin()
    var success: FindSecondaryReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FindSecondaryReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx256_find_secondary_result(success: success)
  }

}



fileprivate final class Apply_db_idx256_lowerbound_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var data: Data

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, data: Data, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.data = data
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx256_lowerbound_args, rhs: Apply_db_idx256_lowerbound_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.data == rhs.data) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx256_lowerbound_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(data)
    hasher.combine(primary)
  }

}

extension Apply_db_idx256_lowerbound_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "data": 4, "primary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_lowerbound_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_lowerbound_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var data: Data!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           data = try Data.read(from: proto)
        case (5, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(data, named: "data")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx256_lowerbound_args(code: code, scope: scope, table: table, data: data, primary: primary)
  }

}



fileprivate final class Apply_db_idx256_lowerbound_result {

  fileprivate var success: LowerBoundUpperBoundReturn?


  fileprivate init() { }
  fileprivate init(success: LowerBoundUpperBoundReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx256_lowerbound_result, rhs: Apply_db_idx256_lowerbound_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx256_lowerbound_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx256_lowerbound_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_lowerbound_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_lowerbound_result {
    _ = try proto.readStructBegin()
    var success: LowerBoundUpperBoundReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LowerBoundUpperBoundReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx256_lowerbound_result(success: success)
  }

}



fileprivate final class Apply_db_idx256_upperbound_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var data: Data

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, data: Data, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.data = data
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx256_upperbound_args, rhs: Apply_db_idx256_upperbound_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.data == rhs.data) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx256_upperbound_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(data)
    hasher.combine(primary)
  }

}

extension Apply_db_idx256_upperbound_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "data": 4, "primary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_upperbound_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_upperbound_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var data: Data!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           data = try Data.read(from: proto)
        case (5, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(data, named: "data")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx256_upperbound_args(code: code, scope: scope, table: table, data: data, primary: primary)
  }

}



fileprivate final class Apply_db_idx256_upperbound_result {

  fileprivate var success: LowerBoundUpperBoundReturn?


  fileprivate init() { }
  fileprivate init(success: LowerBoundUpperBoundReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx256_upperbound_result, rhs: Apply_db_idx256_upperbound_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx256_upperbound_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx256_upperbound_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_upperbound_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_upperbound_result {
    _ = try proto.readStructBegin()
    var success: LowerBoundUpperBoundReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LowerBoundUpperBoundReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx256_upperbound_result(success: success)
  }

}



fileprivate final class Apply_db_idx256_end_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
  }

}

fileprivate func ==(lhs: Apply_db_idx256_end_args, rhs: Apply_db_idx256_end_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table)
}

extension Apply_db_idx256_end_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
  }

}

extension Apply_db_idx256_end_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_end_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_end_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")

    return Apply_db_idx256_end_args(code: code, scope: scope, table: table)
  }

}



fileprivate final class Apply_db_idx256_end_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx256_end_result, rhs: Apply_db_idx256_end_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx256_end_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx256_end_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx256_end_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx256_end_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx256_end_result(success: success)
  }

}



fileprivate final class Apply_db_idx_double_store_args {

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var payer: Uint64

  fileprivate var id: Uint64

  fileprivate var secondary: Data


  fileprivate init(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Data) {
    self.scope = scope
    self.table = table
    self.payer = payer
    self.id = id
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_store_args, rhs: Apply_db_idx_double_store_args) -> Bool {
  return
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.payer == rhs.payer) &&
    (lhs.id == rhs.id) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx_double_store_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(payer)
    hasher.combine(id)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx_double_store_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["scope": 1, "table": 2, "payer": 3, "id": 4, "secondary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_store_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_store_args {
    _ = try proto.readStructBegin()
    var scope: Uint64!
    var table: Uint64!
    var payer: Uint64!
    var id: Uint64!
    var secondary: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           scope = try Uint64.read(from: proto)
        case (2, .struct):           table = try Uint64.read(from: proto)
        case (3, .struct):           payer = try Uint64.read(from: proto)
        case (4, .struct):           id = try Uint64.read(from: proto)
        case (5, .string):           secondary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(id, named: "id")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx_double_store_args(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx_double_store_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_store_result, rhs: Apply_db_idx_double_store_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_double_store_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_double_store_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_store_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_store_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_double_store_result(success: success)
  }

}



fileprivate final class Apply_db_idx_double_update_args {

  fileprivate var iterator: Int32

  fileprivate var payer: Uint64

  fileprivate var secondary: Data


  fileprivate init(iterator: Int32, payer: Uint64, secondary: Data) {
    self.iterator = iterator
    self.payer = payer
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_update_args, rhs: Apply_db_idx_double_update_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.payer == rhs.payer) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx_double_update_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(payer)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx_double_update_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, "payer": 2, "secondary": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_update_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_update_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var payer: Uint64!
    var secondary: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .struct):           payer = try Uint64.read(from: proto)
        case (3, .string):           secondary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx_double_update_args(iterator: iterator, payer: payer, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx_double_update_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_idx_double_update_result, rhs: Apply_db_idx_double_update_result) -> Bool {
  return true
}

extension Apply_db_idx_double_update_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_idx_double_update_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_update_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_update_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_double_update_result()
  }

}



fileprivate final class Apply_db_idx_double_remove_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_remove_args, rhs: Apply_db_idx_double_remove_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx_double_remove_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx_double_remove_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_remove_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_remove_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx_double_remove_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx_double_remove_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_idx_double_remove_result, rhs: Apply_db_idx_double_remove_result) -> Bool {
  return true
}

extension Apply_db_idx_double_remove_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_idx_double_remove_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_remove_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_remove_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_double_remove_result()
  }

}



fileprivate final class Apply_db_idx_double_next_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_next_args, rhs: Apply_db_idx_double_next_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx_double_next_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx_double_next_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_next_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_next_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx_double_next_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx_double_next_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_next_result, rhs: Apply_db_idx_double_next_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_double_next_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_double_next_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_next_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_next_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_double_next_result(success: success)
  }

}



fileprivate final class Apply_db_idx_double_previous_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_previous_args, rhs: Apply_db_idx_double_previous_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx_double_previous_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx_double_previous_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_previous_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_previous_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx_double_previous_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx_double_previous_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_previous_result, rhs: Apply_db_idx_double_previous_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_double_previous_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_double_previous_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_previous_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_previous_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_double_previous_result(success: success)
  }

}



fileprivate final class Apply_db_idx_double_find_primary_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_find_primary_args, rhs: Apply_db_idx_double_find_primary_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx_double_find_primary_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(primary)
  }

}

extension Apply_db_idx_double_find_primary_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "primary": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_find_primary_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_find_primary_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx_double_find_primary_args(code: code, scope: scope, table: table, primary: primary)
  }

}



fileprivate final class Apply_db_idx_double_find_primary_result {

  fileprivate var success: FindPrimaryReturn?


  fileprivate init() { }
  fileprivate init(success: FindPrimaryReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_find_primary_result, rhs: Apply_db_idx_double_find_primary_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_double_find_primary_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_double_find_primary_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_find_primary_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_find_primary_result {
    _ = try proto.readStructBegin()
    var success: FindPrimaryReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FindPrimaryReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_double_find_primary_result(success: success)
  }

}



fileprivate final class Apply_db_idx_double_find_secondary_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Data


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Data) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_find_secondary_args, rhs: Apply_db_idx_double_find_secondary_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx_double_find_secondary_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx_double_find_secondary_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_find_secondary_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_find_secondary_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           secondary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx_double_find_secondary_args(code: code, scope: scope, table: table, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx_double_find_secondary_result {

  fileprivate var success: FindSecondaryReturn?


  fileprivate init() { }
  fileprivate init(success: FindSecondaryReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_find_secondary_result, rhs: Apply_db_idx_double_find_secondary_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_double_find_secondary_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_double_find_secondary_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_find_secondary_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_find_secondary_result {
    _ = try proto.readStructBegin()
    var success: FindSecondaryReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FindSecondaryReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_double_find_secondary_result(success: success)
  }

}



fileprivate final class Apply_db_idx_double_lowerbound_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Data

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_lowerbound_args, rhs: Apply_db_idx_double_lowerbound_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx_double_lowerbound_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
    hasher.combine(primary)
  }

}

extension Apply_db_idx_double_lowerbound_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, "primary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_lowerbound_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_lowerbound_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Data!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           secondary = try Data.read(from: proto)
        case (5, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx_double_lowerbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
  }

}



fileprivate final class Apply_db_idx_double_lowerbound_result {

  fileprivate var success: LowerBoundUpperBoundReturn?


  fileprivate init() { }
  fileprivate init(success: LowerBoundUpperBoundReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_lowerbound_result, rhs: Apply_db_idx_double_lowerbound_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_double_lowerbound_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_double_lowerbound_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_lowerbound_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_lowerbound_result {
    _ = try proto.readStructBegin()
    var success: LowerBoundUpperBoundReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LowerBoundUpperBoundReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_double_lowerbound_result(success: success)
  }

}



fileprivate final class Apply_db_idx_double_upperbound_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Data

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_upperbound_args, rhs: Apply_db_idx_double_upperbound_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx_double_upperbound_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
    hasher.combine(primary)
  }

}

extension Apply_db_idx_double_upperbound_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, "primary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_upperbound_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_upperbound_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Data!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           secondary = try Data.read(from: proto)
        case (5, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx_double_upperbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
  }

}



fileprivate final class Apply_db_idx_double_upperbound_result {

  fileprivate var success: LowerBoundUpperBoundReturn?


  fileprivate init() { }
  fileprivate init(success: LowerBoundUpperBoundReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_upperbound_result, rhs: Apply_db_idx_double_upperbound_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_double_upperbound_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_double_upperbound_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_upperbound_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_upperbound_result {
    _ = try proto.readStructBegin()
    var success: LowerBoundUpperBoundReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LowerBoundUpperBoundReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_double_upperbound_result(success: success)
  }

}



fileprivate final class Apply_db_idx_double_end_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_end_args, rhs: Apply_db_idx_double_end_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table)
}

extension Apply_db_idx_double_end_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
  }

}

extension Apply_db_idx_double_end_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_end_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_end_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")

    return Apply_db_idx_double_end_args(code: code, scope: scope, table: table)
  }

}



fileprivate final class Apply_db_idx_double_end_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_double_end_result, rhs: Apply_db_idx_double_end_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_double_end_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_double_end_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_double_end_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_double_end_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_double_end_result(success: success)
  }

}



fileprivate final class Apply_db_idx_long_double_store_args {

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var payer: Uint64

  fileprivate var id: Uint64

  fileprivate var secondary: Data


  fileprivate init(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Data) {
    self.scope = scope
    self.table = table
    self.payer = payer
    self.id = id
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_store_args, rhs: Apply_db_idx_long_double_store_args) -> Bool {
  return
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.payer == rhs.payer) &&
    (lhs.id == rhs.id) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx_long_double_store_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(payer)
    hasher.combine(id)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx_long_double_store_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["scope": 1, "table": 2, "payer": 3, "id": 4, "secondary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_store_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_store_args {
    _ = try proto.readStructBegin()
    var scope: Uint64!
    var table: Uint64!
    var payer: Uint64!
    var id: Uint64!
    var secondary: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           scope = try Uint64.read(from: proto)
        case (2, .struct):           table = try Uint64.read(from: proto)
        case (3, .struct):           payer = try Uint64.read(from: proto)
        case (4, .struct):           id = try Uint64.read(from: proto)
        case (5, .string):           secondary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(id, named: "id")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx_long_double_store_args(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx_long_double_store_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_store_result, rhs: Apply_db_idx_long_double_store_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_long_double_store_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_long_double_store_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_store_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_store_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_long_double_store_result(success: success)
  }

}



fileprivate final class Apply_db_idx_long_double_update_args {

  fileprivate var iterator: Int32

  fileprivate var payer: Uint64

  fileprivate var secondary: Data


  fileprivate init(iterator: Int32, payer: Uint64, secondary: Data) {
    self.iterator = iterator
    self.payer = payer
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_update_args, rhs: Apply_db_idx_long_double_update_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator) &&
    (lhs.payer == rhs.payer) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx_long_double_update_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
    hasher.combine(payer)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx_long_double_update_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, "payer": 2, "secondary": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_update_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_update_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!
    var payer: Uint64!
    var secondary: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case (2, .struct):           payer = try Uint64.read(from: proto)
        case (3, .string):           secondary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")
    try proto.validateValue(payer, named: "payer")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx_long_double_update_args(iterator: iterator, payer: payer, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx_long_double_update_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_idx_long_double_update_result, rhs: Apply_db_idx_long_double_update_result) -> Bool {
  return true
}

extension Apply_db_idx_long_double_update_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_idx_long_double_update_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_update_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_update_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_long_double_update_result()
  }

}



fileprivate final class Apply_db_idx_long_double_remove_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_remove_args, rhs: Apply_db_idx_long_double_remove_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx_long_double_remove_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx_long_double_remove_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_remove_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_remove_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx_long_double_remove_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx_long_double_remove_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Apply_db_idx_long_double_remove_result, rhs: Apply_db_idx_long_double_remove_result) -> Bool {
  return true
}

extension Apply_db_idx_long_double_remove_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Apply_db_idx_long_double_remove_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_remove_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_remove_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_long_double_remove_result()
  }

}



fileprivate final class Apply_db_idx_long_double_next_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_next_args, rhs: Apply_db_idx_long_double_next_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx_long_double_next_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx_long_double_next_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_next_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_next_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx_long_double_next_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx_long_double_next_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_next_result, rhs: Apply_db_idx_long_double_next_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_long_double_next_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_long_double_next_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_next_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_next_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_long_double_next_result(success: success)
  }

}



fileprivate final class Apply_db_idx_long_double_previous_args {

  fileprivate var iterator: Int32


  fileprivate init(iterator: Int32) {
    self.iterator = iterator
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_previous_args, rhs: Apply_db_idx_long_double_previous_args) -> Bool {
  return
    (lhs.iterator == rhs.iterator)
}

extension Apply_db_idx_long_double_previous_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(iterator)
  }

}

extension Apply_db_idx_long_double_previous_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["iterator": 1, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_previous_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_previous_args {
    _ = try proto.readStructBegin()
    var iterator: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             iterator = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iterator, named: "iterator")

    return Apply_db_idx_long_double_previous_args(iterator: iterator)
  }

}



fileprivate final class Apply_db_idx_long_double_previous_result {

  fileprivate var success: NextPreviousReturn?


  fileprivate init() { }
  fileprivate init(success: NextPreviousReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_previous_result, rhs: Apply_db_idx_long_double_previous_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_long_double_previous_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_long_double_previous_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_previous_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_previous_result {
    _ = try proto.readStructBegin()
    var success: NextPreviousReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try NextPreviousReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_long_double_previous_result(success: success)
  }

}



fileprivate final class Apply_db_idx_long_double_find_primary_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_find_primary_args, rhs: Apply_db_idx_long_double_find_primary_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx_long_double_find_primary_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(primary)
  }

}

extension Apply_db_idx_long_double_find_primary_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "primary": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_find_primary_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_find_primary_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx_long_double_find_primary_args(code: code, scope: scope, table: table, primary: primary)
  }

}



fileprivate final class Apply_db_idx_long_double_find_primary_result {

  fileprivate var success: FindPrimaryReturn?


  fileprivate init() { }
  fileprivate init(success: FindPrimaryReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_find_primary_result, rhs: Apply_db_idx_long_double_find_primary_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_long_double_find_primary_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_long_double_find_primary_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_find_primary_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_find_primary_result {
    _ = try proto.readStructBegin()
    var success: FindPrimaryReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FindPrimaryReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_long_double_find_primary_result(success: success)
  }

}



fileprivate final class Apply_db_idx_long_double_find_secondary_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Data


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Data) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_find_secondary_args, rhs: Apply_db_idx_long_double_find_secondary_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary)
}

extension Apply_db_idx_long_double_find_secondary_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
  }

}

extension Apply_db_idx_long_double_find_secondary_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_find_secondary_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_find_secondary_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           secondary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")

    return Apply_db_idx_long_double_find_secondary_args(code: code, scope: scope, table: table, secondary: secondary)
  }

}



fileprivate final class Apply_db_idx_long_double_find_secondary_result {

  fileprivate var success: FindSecondaryReturn?


  fileprivate init() { }
  fileprivate init(success: FindSecondaryReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_find_secondary_result, rhs: Apply_db_idx_long_double_find_secondary_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_long_double_find_secondary_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_long_double_find_secondary_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_find_secondary_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_find_secondary_result {
    _ = try proto.readStructBegin()
    var success: FindSecondaryReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try FindSecondaryReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_long_double_find_secondary_result(success: success)
  }

}



fileprivate final class Apply_db_idx_long_double_lowerbound_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Data

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_lowerbound_args, rhs: Apply_db_idx_long_double_lowerbound_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx_long_double_lowerbound_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
    hasher.combine(primary)
  }

}

extension Apply_db_idx_long_double_lowerbound_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, "primary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_lowerbound_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_lowerbound_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Data!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           secondary = try Data.read(from: proto)
        case (5, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx_long_double_lowerbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
  }

}



fileprivate final class Apply_db_idx_long_double_lowerbound_result {

  fileprivate var success: LowerBoundUpperBoundReturn?


  fileprivate init() { }
  fileprivate init(success: LowerBoundUpperBoundReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_lowerbound_result, rhs: Apply_db_idx_long_double_lowerbound_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_long_double_lowerbound_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_long_double_lowerbound_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_lowerbound_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_lowerbound_result {
    _ = try proto.readStructBegin()
    var success: LowerBoundUpperBoundReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LowerBoundUpperBoundReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_long_double_lowerbound_result(success: success)
  }

}



fileprivate final class Apply_db_idx_long_double_upperbound_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64

  fileprivate var secondary: Data

  fileprivate var primary: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
    self.secondary = secondary
    self.primary = primary
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_upperbound_args, rhs: Apply_db_idx_long_double_upperbound_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table) &&
    (lhs.secondary == rhs.secondary) &&
    (lhs.primary == rhs.primary)
}

extension Apply_db_idx_long_double_upperbound_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
    hasher.combine(secondary)
    hasher.combine(primary)
  }

}

extension Apply_db_idx_long_double_upperbound_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, "secondary": 4, "primary": 5, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_upperbound_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_upperbound_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!
    var secondary: Data!
    var primary: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case (4, .string):           secondary = try Data.read(from: proto)
        case (5, .struct):           primary = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")
    try proto.validateValue(secondary, named: "secondary")
    try proto.validateValue(primary, named: "primary")

    return Apply_db_idx_long_double_upperbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
  }

}



fileprivate final class Apply_db_idx_long_double_upperbound_result {

  fileprivate var success: LowerBoundUpperBoundReturn?


  fileprivate init() { }
  fileprivate init(success: LowerBoundUpperBoundReturn?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_upperbound_result, rhs: Apply_db_idx_long_double_upperbound_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_long_double_upperbound_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_long_double_upperbound_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_upperbound_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_upperbound_result {
    _ = try proto.readStructBegin()
    var success: LowerBoundUpperBoundReturn?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LowerBoundUpperBoundReturn.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_long_double_upperbound_result(success: success)
  }

}



fileprivate final class Apply_db_idx_long_double_end_args {

  fileprivate var code: Uint64

  fileprivate var scope: Uint64

  fileprivate var table: Uint64


  fileprivate init(code: Uint64, scope: Uint64, table: Uint64) {
    self.code = code
    self.scope = scope
    self.table = table
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_end_args, rhs: Apply_db_idx_long_double_end_args) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.scope == rhs.scope) &&
    (lhs.table == rhs.table)
}

extension Apply_db_idx_long_double_end_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(code)
    hasher.combine(scope)
    hasher.combine(table)
  }

}

extension Apply_db_idx_long_double_end_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["code": 1, "scope": 2, "table": 3, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_end_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_end_args {
    _ = try proto.readStructBegin()
    var code: Uint64!
    var scope: Uint64!
    var table: Uint64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           code = try Uint64.read(from: proto)
        case (2, .struct):           scope = try Uint64.read(from: proto)
        case (3, .struct):           table = try Uint64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(scope, named: "scope")
    try proto.validateValue(table, named: "table")

    return Apply_db_idx_long_double_end_args(code: code, scope: scope, table: table)
  }

}



fileprivate final class Apply_db_idx_long_double_end_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Apply_db_idx_long_double_end_result, rhs: Apply_db_idx_long_double_end_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Apply_db_idx_long_double_end_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Apply_db_idx_long_double_end_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Apply_db_idx_long_double_end_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Apply_db_idx_long_double_end_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Apply_db_idx_long_double_end_result(success: success)
  }

}



extension ApplyClient : Apply {

  private func send_end_apply() throws {
    try outProtocol.writeMessageBegin(name: "end_apply", type: .call, sequenceID: 0)
    let args = Apply_end_apply_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_end_apply() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_end_apply_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "end_apply"))
  }

  public func end_apply() throws -> Int32 {
    try send_end_apply()
    try outProtocol.transport.flush()
    return try recv_end_apply()
  }

  private func send_get_active_producers() throws {
    try outProtocol.writeMessageBegin(name: "get_active_producers", type: .call, sequenceID: 0)
    let args = Apply_get_active_producers_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_active_producers() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_get_active_producers_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_active_producers"))
  }

  public func get_active_producers() throws -> Data {
    try send_get_active_producers()
    try outProtocol.transport.flush()
    return try recv_get_active_producers()
  }

  private func send_get_resource_limits(account: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "get_resource_limits", type: .call, sequenceID: 0)
    let args = Apply_get_resource_limits_args(account: account)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_resource_limits() throws -> GetResourceLimitsReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_get_resource_limits_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_resource_limits"))
  }

  public func get_resource_limits(account: Uint64) throws -> GetResourceLimitsReturn {
    try send_get_resource_limits(account: account)
    try outProtocol.transport.flush()
    return try recv_get_resource_limits()
  }

  private func send_set_resource_limits(account: Uint64, ram_bytes: Int64, net_weight: Int64, cpu_weight: Int64) throws {
    try outProtocol.writeMessageBegin(name: "set_resource_limits", type: .call, sequenceID: 0)
    let args = Apply_set_resource_limits_args(account: account, ram_bytes: ram_bytes, net_weight: net_weight, cpu_weight: cpu_weight)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_set_resource_limits() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_set_resource_limits_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func set_resource_limits(account: Uint64, ram_bytes: Int64, net_weight: Int64, cpu_weight: Int64) throws {
    try send_set_resource_limits(account: account, ram_bytes: ram_bytes, net_weight: net_weight, cpu_weight: cpu_weight)
    try outProtocol.transport.flush()
    try recv_set_resource_limits()
  }

  private func send_set_proposed_producers(producer_data: Data) throws {
    try outProtocol.writeMessageBegin(name: "set_proposed_producers", type: .call, sequenceID: 0)
    let args = Apply_set_proposed_producers_args(producer_data: producer_data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_set_proposed_producers() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_set_proposed_producers_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "set_proposed_producers"))
  }

  public func set_proposed_producers(producer_data: Data) throws -> Int64 {
    try send_set_proposed_producers(producer_data: producer_data)
    try outProtocol.transport.flush()
    return try recv_set_proposed_producers()
  }

  private func send_set_proposed_producers_ex(producer_data_format: Uint64, producer_data: Data) throws {
    try outProtocol.writeMessageBegin(name: "set_proposed_producers_ex", type: .call, sequenceID: 0)
    let args = Apply_set_proposed_producers_ex_args(producer_data_format: producer_data_format, producer_data: producer_data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_set_proposed_producers_ex() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_set_proposed_producers_ex_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "set_proposed_producers_ex"))
  }

  public func set_proposed_producers_ex(producer_data_format: Uint64, producer_data: Data) throws -> Int64 {
    try send_set_proposed_producers_ex(producer_data_format: producer_data_format, producer_data: producer_data)
    try outProtocol.transport.flush()
    return try recv_set_proposed_producers_ex()
  }

  private func send_is_privileged(account: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "is_privileged", type: .call, sequenceID: 0)
    let args = Apply_is_privileged_args(account: account)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_is_privileged() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_is_privileged_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "is_privileged"))
  }

  public func is_privileged(account: Uint64) throws -> Bool {
    try send_is_privileged(account: account)
    try outProtocol.transport.flush()
    return try recv_is_privileged()
  }

  private func send_set_privileged(account: Uint64, is_priv: Bool) throws {
    try outProtocol.writeMessageBegin(name: "set_privileged", type: .call, sequenceID: 0)
    let args = Apply_set_privileged_args(account: account, is_priv: is_priv)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_set_privileged() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_set_privileged_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func set_privileged(account: Uint64, is_priv: Bool) throws {
    try send_set_privileged(account: account, is_priv: is_priv)
    try outProtocol.transport.flush()
    try recv_set_privileged()
  }

  private func send_set_blockchain_parameters_packed(data: Data) throws {
    try outProtocol.writeMessageBegin(name: "set_blockchain_parameters_packed", type: .call, sequenceID: 0)
    let args = Apply_set_blockchain_parameters_packed_args(data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_set_blockchain_parameters_packed() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_set_blockchain_parameters_packed_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func set_blockchain_parameters_packed(data: Data) throws {
    try send_set_blockchain_parameters_packed(data: data)
    try outProtocol.transport.flush()
    try recv_set_blockchain_parameters_packed()
  }

  private func send_get_blockchain_parameters_packed() throws {
    try outProtocol.writeMessageBegin(name: "get_blockchain_parameters_packed", type: .call, sequenceID: 0)
    let args = Apply_get_blockchain_parameters_packed_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_blockchain_parameters_packed() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_get_blockchain_parameters_packed_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_blockchain_parameters_packed"))
  }

  public func get_blockchain_parameters_packed() throws -> Data {
    try send_get_blockchain_parameters_packed()
    try outProtocol.transport.flush()
    return try recv_get_blockchain_parameters_packed()
  }

  private func send_preactivate_feature(feature_digest: Data) throws {
    try outProtocol.writeMessageBegin(name: "preactivate_feature", type: .call, sequenceID: 0)
    let args = Apply_preactivate_feature_args(feature_digest: feature_digest)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_preactivate_feature() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_preactivate_feature_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func preactivate_feature(feature_digest: Data) throws {
    try send_preactivate_feature(feature_digest: feature_digest)
    try outProtocol.transport.flush()
    try recv_preactivate_feature()
  }

  private func send_check_transaction_authorization(trx_data: Data, pubkeys_data: Data, perms_data: Data) throws {
    try outProtocol.writeMessageBegin(name: "check_transaction_authorization", type: .call, sequenceID: 0)
    let args = Apply_check_transaction_authorization_args(trx_data: trx_data, pubkeys_data: pubkeys_data, perms_data: perms_data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_check_transaction_authorization() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_check_transaction_authorization_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "check_transaction_authorization"))
  }

  public func check_transaction_authorization(trx_data: Data, pubkeys_data: Data, perms_data: Data) throws -> Int32 {
    try send_check_transaction_authorization(trx_data: trx_data, pubkeys_data: pubkeys_data, perms_data: perms_data)
    try outProtocol.transport.flush()
    return try recv_check_transaction_authorization()
  }

  private func send_check_permission_authorization(account: Uint64, permission: Uint64, pubkeys_data: Data, perms_data: Data, delay_us: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "check_permission_authorization", type: .call, sequenceID: 0)
    let args = Apply_check_permission_authorization_args(account: account, permission: permission, pubkeys_data: pubkeys_data, perms_data: perms_data, delay_us: delay_us)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_check_permission_authorization() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_check_permission_authorization_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "check_permission_authorization"))
  }

  public func check_permission_authorization(account: Uint64, permission: Uint64, pubkeys_data: Data, perms_data: Data, delay_us: Uint64) throws -> Int32 {
    try send_check_permission_authorization(account: account, permission: permission, pubkeys_data: pubkeys_data, perms_data: perms_data, delay_us: delay_us)
    try outProtocol.transport.flush()
    return try recv_check_permission_authorization()
  }

  private func send_get_permission_last_used(account: Uint64, permission: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "get_permission_last_used", type: .call, sequenceID: 0)
    let args = Apply_get_permission_last_used_args(account: account, permission: permission)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_permission_last_used() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_get_permission_last_used_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_permission_last_used"))
  }

  public func get_permission_last_used(account: Uint64, permission: Uint64) throws -> Int64 {
    try send_get_permission_last_used(account: account, permission: permission)
    try outProtocol.transport.flush()
    return try recv_get_permission_last_used()
  }

  private func send_get_account_creation_time(account: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "get_account_creation_time", type: .call, sequenceID: 0)
    let args = Apply_get_account_creation_time_args(account: account)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_account_creation_time() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_get_account_creation_time_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_account_creation_time"))
  }

  public func get_account_creation_time(account: Uint64) throws -> Int64 {
    try send_get_account_creation_time(account: account)
    try outProtocol.transport.flush()
    return try recv_get_account_creation_time()
  }

  private func send_prints(cstr: String) throws {
    try outProtocol.writeMessageBegin(name: "prints", type: .call, sequenceID: 0)
    let args = Apply_prints_args(cstr: cstr)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_prints() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_prints_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func prints(cstr: String) throws {
    try send_prints(cstr: cstr)
    try outProtocol.transport.flush()
    try recv_prints()
  }

  private func send_prints_l(cstr: Data) throws {
    try outProtocol.writeMessageBegin(name: "prints_l", type: .call, sequenceID: 0)
    let args = Apply_prints_l_args(cstr: cstr)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_prints_l() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_prints_l_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func prints_l(cstr: Data) throws {
    try send_prints_l(cstr: cstr)
    try outProtocol.transport.flush()
    try recv_prints_l()
  }

  private func send_printi(n: Int64) throws {
    try outProtocol.writeMessageBegin(name: "printi", type: .call, sequenceID: 0)
    let args = Apply_printi_args(n: n)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_printi() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_printi_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func printi(n: Int64) throws {
    try send_printi(n: n)
    try outProtocol.transport.flush()
    try recv_printi()
  }

  private func send_printui(n: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "printui", type: .call, sequenceID: 0)
    let args = Apply_printui_args(n: n)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_printui() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_printui_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func printui(n: Uint64) throws {
    try send_printui(n: n)
    try outProtocol.transport.flush()
    try recv_printui()
  }

  private func send_printi128(value: Data) throws {
    try outProtocol.writeMessageBegin(name: "printi128", type: .call, sequenceID: 0)
    let args = Apply_printi128_args(value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_printi128() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_printi128_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func printi128(value: Data) throws {
    try send_printi128(value: value)
    try outProtocol.transport.flush()
    try recv_printi128()
  }

  private func send_printui128(value: Data) throws {
    try outProtocol.writeMessageBegin(name: "printui128", type: .call, sequenceID: 0)
    let args = Apply_printui128_args(value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_printui128() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_printui128_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func printui128(value: Data) throws {
    try send_printui128(value: value)
    try outProtocol.transport.flush()
    try recv_printui128()
  }

  private func send_printsf(value: Data) throws {
    try outProtocol.writeMessageBegin(name: "printsf", type: .call, sequenceID: 0)
    let args = Apply_printsf_args(value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_printsf() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_printsf_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func printsf(value: Data) throws {
    try send_printsf(value: value)
    try outProtocol.transport.flush()
    try recv_printsf()
  }

  private func send_printdf(value: Data) throws {
    try outProtocol.writeMessageBegin(name: "printdf", type: .call, sequenceID: 0)
    let args = Apply_printdf_args(value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_printdf() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_printdf_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func printdf(value: Data) throws {
    try send_printdf(value: value)
    try outProtocol.transport.flush()
    try recv_printdf()
  }

  private func send_printqf(value: Data) throws {
    try outProtocol.writeMessageBegin(name: "printqf", type: .call, sequenceID: 0)
    let args = Apply_printqf_args(value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_printqf() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_printqf_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func printqf(value: Data) throws {
    try send_printqf(value: value)
    try outProtocol.transport.flush()
    try recv_printqf()
  }

  private func send_printn(name: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "printn", type: .call, sequenceID: 0)
    let args = Apply_printn_args(name: name)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_printn() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_printn_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func printn(name: Uint64) throws {
    try send_printn(name: name)
    try outProtocol.transport.flush()
    try recv_printn()
  }

  private func send_printhex(data: Data) throws {
    try outProtocol.writeMessageBegin(name: "printhex", type: .call, sequenceID: 0)
    let args = Apply_printhex_args(data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_printhex() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_printhex_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func printhex(data: Data) throws {
    try send_printhex(data: data)
    try outProtocol.transport.flush()
    try recv_printhex()
  }

  private func send_action_data_size() throws {
    try outProtocol.writeMessageBegin(name: "action_data_size", type: .call, sequenceID: 0)
    let args = Apply_action_data_size_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_action_data_size() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_action_data_size_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "action_data_size"))
  }

  public func action_data_size() throws -> Int32 {
    try send_action_data_size()
    try outProtocol.transport.flush()
    return try recv_action_data_size()
  }

  private func send_read_action_data() throws {
    try outProtocol.writeMessageBegin(name: "read_action_data", type: .call, sequenceID: 0)
    let args = Apply_read_action_data_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_read_action_data() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_read_action_data_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "read_action_data"))
  }

  public func read_action_data() throws -> Data {
    try send_read_action_data()
    try outProtocol.transport.flush()
    return try recv_read_action_data()
  }

  private func send_require_recipient(name: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "require_recipient", type: .call, sequenceID: 0)
    let args = Apply_require_recipient_args(name: name)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_require_recipient() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_require_recipient_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func require_recipient(name: Uint64) throws {
    try send_require_recipient(name: name)
    try outProtocol.transport.flush()
    try recv_require_recipient()
  }

  private func send_require_auth(name: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "require_auth", type: .call, sequenceID: 0)
    let args = Apply_require_auth_args(name: name)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_require_auth() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_require_auth_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func require_auth(name: Uint64) throws {
    try send_require_auth(name: name)
    try outProtocol.transport.flush()
    try recv_require_auth()
  }

  private func send_has_auth(name: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "has_auth", type: .call, sequenceID: 0)
    let args = Apply_has_auth_args(name: name)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_has_auth() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_has_auth_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "has_auth"))
  }

  public func has_auth(name: Uint64) throws -> Bool {
    try send_has_auth(name: name)
    try outProtocol.transport.flush()
    return try recv_has_auth()
  }

  private func send_require_auth2(name: Uint64, permission: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "require_auth2", type: .call, sequenceID: 0)
    let args = Apply_require_auth2_args(name: name, permission: permission)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_require_auth2() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_require_auth2_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func require_auth2(name: Uint64, permission: Uint64) throws {
    try send_require_auth2(name: name, permission: permission)
    try outProtocol.transport.flush()
    try recv_require_auth2()
  }

  private func send_is_account(name: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "is_account", type: .call, sequenceID: 0)
    let args = Apply_is_account_args(name: name)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_is_account() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_is_account_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "is_account"))
  }

  public func is_account(name: Uint64) throws -> Bool {
    try send_is_account(name: name)
    try outProtocol.transport.flush()
    return try recv_is_account()
  }

  private func send_send_inline(serialized_action: Data) throws {
    try outProtocol.writeMessageBegin(name: "send_inline", type: .call, sequenceID: 0)
    let args = Apply_send_inline_args(serialized_action: serialized_action)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_send_inline() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_send_inline_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func send_inline(serialized_action: Data) throws {
    try send_send_inline(serialized_action: serialized_action)
    try outProtocol.transport.flush()
    try recv_send_inline()
  }

  private func send_send_context_free_inline(serialized_data: Data) throws {
    try outProtocol.writeMessageBegin(name: "send_context_free_inline", type: .call, sequenceID: 0)
    let args = Apply_send_context_free_inline_args(serialized_data: serialized_data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_send_context_free_inline() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_send_context_free_inline_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func send_context_free_inline(serialized_data: Data) throws {
    try send_send_context_free_inline(serialized_data: serialized_data)
    try outProtocol.transport.flush()
    try recv_send_context_free_inline()
  }

  private func send_publication_time() throws {
    try outProtocol.writeMessageBegin(name: "publication_time", type: .call, sequenceID: 0)
    let args = Apply_publication_time_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_publication_time() throws -> Uint64 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_publication_time_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "publication_time"))
  }

  public func publication_time() throws -> Uint64 {
    try send_publication_time()
    try outProtocol.transport.flush()
    return try recv_publication_time()
  }

  private func send_current_receiver() throws {
    try outProtocol.writeMessageBegin(name: "current_receiver", type: .call, sequenceID: 0)
    let args = Apply_current_receiver_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_current_receiver() throws -> Uint64 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_current_receiver_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "current_receiver"))
  }

  public func current_receiver() throws -> Uint64 {
    try send_current_receiver()
    try outProtocol.transport.flush()
    return try recv_current_receiver()
  }

  private func send_eosio_assert(test: Bool, msg: Data) throws {
    try outProtocol.writeMessageBegin(name: "eosio_assert", type: .call, sequenceID: 0)
    let args = Apply_eosio_assert_args(test: test, msg: msg)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_eosio_assert() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_eosio_assert_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func eosio_assert(test: Bool, msg: Data) throws {
    try send_eosio_assert(test: test, msg: msg)
    try outProtocol.transport.flush()
    try recv_eosio_assert()
  }

  private func send_eosio_assert_message(test: Bool, msg: Data) throws {
    try outProtocol.writeMessageBegin(name: "eosio_assert_message", type: .call, sequenceID: 0)
    let args = Apply_eosio_assert_message_args(test: test, msg: msg)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_eosio_assert_message() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_eosio_assert_message_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func eosio_assert_message(test: Bool, msg: Data) throws {
    try send_eosio_assert_message(test: test, msg: msg)
    try outProtocol.transport.flush()
    try recv_eosio_assert_message()
  }

  private func send_eosio_assert_code(test: Bool, code: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "eosio_assert_code", type: .call, sequenceID: 0)
    let args = Apply_eosio_assert_code_args(test: test, code: code)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_eosio_assert_code() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_eosio_assert_code_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func eosio_assert_code(test: Bool, code: Uint64) throws {
    try send_eosio_assert_code(test: test, code: code)
    try outProtocol.transport.flush()
    try recv_eosio_assert_code()
  }

  private func send_eosio_exit(code: Int32) throws {
    try outProtocol.writeMessageBegin(name: "eosio_exit", type: .call, sequenceID: 0)
    let args = Apply_eosio_exit_args(code: code)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_eosio_exit() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_eosio_exit_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func eosio_exit(code: Int32) throws {
    try send_eosio_exit(code: code)
    try outProtocol.transport.flush()
    try recv_eosio_exit()
  }

  private func send_current_time() throws {
    try outProtocol.writeMessageBegin(name: "current_time", type: .call, sequenceID: 0)
    let args = Apply_current_time_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_current_time() throws -> Uint64 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_current_time_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "current_time"))
  }

  public func current_time() throws -> Uint64 {
    try send_current_time()
    try outProtocol.transport.flush()
    return try recv_current_time()
  }

  private func send_is_feature_activated(feature_digest: Data) throws {
    try outProtocol.writeMessageBegin(name: "is_feature_activated", type: .call, sequenceID: 0)
    let args = Apply_is_feature_activated_args(feature_digest: feature_digest)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_is_feature_activated() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_is_feature_activated_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "is_feature_activated"))
  }

  public func is_feature_activated(feature_digest: Data) throws -> Bool {
    try send_is_feature_activated(feature_digest: feature_digest)
    try outProtocol.transport.flush()
    return try recv_is_feature_activated()
  }

  private func send_get_sender() throws {
    try outProtocol.writeMessageBegin(name: "get_sender", type: .call, sequenceID: 0)
    let args = Apply_get_sender_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_sender() throws -> Uint64 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_get_sender_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_sender"))
  }

  public func get_sender() throws -> Uint64 {
    try send_get_sender()
    try outProtocol.transport.flush()
    return try recv_get_sender()
  }

  private func send_assert_sha256(data: Data, hash: Data) throws {
    try outProtocol.writeMessageBegin(name: "assert_sha256", type: .call, sequenceID: 0)
    let args = Apply_assert_sha256_args(data: data, hash: hash)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_assert_sha256() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_assert_sha256_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func assert_sha256(data: Data, hash: Data) throws {
    try send_assert_sha256(data: data, hash: hash)
    try outProtocol.transport.flush()
    try recv_assert_sha256()
  }

  private func send_assert_sha1(data: Data, hash: Data) throws {
    try outProtocol.writeMessageBegin(name: "assert_sha1", type: .call, sequenceID: 0)
    let args = Apply_assert_sha1_args(data: data, hash: hash)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_assert_sha1() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_assert_sha1_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func assert_sha1(data: Data, hash: Data) throws {
    try send_assert_sha1(data: data, hash: hash)
    try outProtocol.transport.flush()
    try recv_assert_sha1()
  }

  private func send_assert_sha512(data: Data, hash: Data) throws {
    try outProtocol.writeMessageBegin(name: "assert_sha512", type: .call, sequenceID: 0)
    let args = Apply_assert_sha512_args(data: data, hash: hash)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_assert_sha512() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_assert_sha512_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func assert_sha512(data: Data, hash: Data) throws {
    try send_assert_sha512(data: data, hash: hash)
    try outProtocol.transport.flush()
    try recv_assert_sha512()
  }

  private func send_assert_ripemd160(data: Data, hash: Data) throws {
    try outProtocol.writeMessageBegin(name: "assert_ripemd160", type: .call, sequenceID: 0)
    let args = Apply_assert_ripemd160_args(data: data, hash: hash)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_assert_ripemd160() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_assert_ripemd160_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func assert_ripemd160(data: Data, hash: Data) throws {
    try send_assert_ripemd160(data: data, hash: hash)
    try outProtocol.transport.flush()
    try recv_assert_ripemd160()
  }

  private func send_sha256(data: Data) throws {
    try outProtocol.writeMessageBegin(name: "sha256", type: .call, sequenceID: 0)
    let args = Apply_sha256_args(data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sha256() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_sha256_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "sha256"))
  }

  public func sha256(data: Data) throws -> Data {
    try send_sha256(data: data)
    try outProtocol.transport.flush()
    return try recv_sha256()
  }

  private func send_sha1(data: Data) throws {
    try outProtocol.writeMessageBegin(name: "sha1", type: .call, sequenceID: 0)
    let args = Apply_sha1_args(data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sha1() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_sha1_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "sha1"))
  }

  public func sha1(data: Data) throws -> Data {
    try send_sha1(data: data)
    try outProtocol.transport.flush()
    return try recv_sha1()
  }

  private func send_sha512(data: Data) throws {
    try outProtocol.writeMessageBegin(name: "sha512", type: .call, sequenceID: 0)
    let args = Apply_sha512_args(data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sha512() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_sha512_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "sha512"))
  }

  public func sha512(data: Data) throws -> Data {
    try send_sha512(data: data)
    try outProtocol.transport.flush()
    return try recv_sha512()
  }

  private func send_ripemd160(data: Data) throws {
    try outProtocol.writeMessageBegin(name: "ripemd160", type: .call, sequenceID: 0)
    let args = Apply_ripemd160_args(data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_ripemd160() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_ripemd160_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "ripemd160"))
  }

  public func ripemd160(data: Data) throws -> Data {
    try send_ripemd160(data: data)
    try outProtocol.transport.flush()
    return try recv_ripemd160()
  }

  private func send_recover_key(digest: Data, sig: Data) throws {
    try outProtocol.writeMessageBegin(name: "recover_key", type: .call, sequenceID: 0)
    let args = Apply_recover_key_args(digest: digest, sig: sig)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_recover_key() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_recover_key_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "recover_key"))
  }

  public func recover_key(digest: Data, sig: Data) throws -> Data {
    try send_recover_key(digest: digest, sig: sig)
    try outProtocol.transport.flush()
    return try recv_recover_key()
  }

  private func send_assert_recover_key(digest: Data, sig: Data, pub: Data) throws {
    try outProtocol.writeMessageBegin(name: "assert_recover_key", type: .call, sequenceID: 0)
    let args = Apply_assert_recover_key_args(digest: digest, sig: sig, pub: pub)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_assert_recover_key() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_assert_recover_key_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func assert_recover_key(digest: Data, sig: Data, pub: Data) throws {
    try send_assert_recover_key(digest: digest, sig: sig, pub: pub)
    try outProtocol.transport.flush()
    try recv_assert_recover_key()
  }

  private func send_send_deferred(sender_id: Data, payer: Uint64, serialized_transaction: Data, replace_existing: Int32) throws {
    try outProtocol.writeMessageBegin(name: "send_deferred", type: .call, sequenceID: 0)
    let args = Apply_send_deferred_args(sender_id: sender_id, payer: payer, serialized_transaction: serialized_transaction, replace_existing: replace_existing)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_send_deferred() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_send_deferred_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func send_deferred(sender_id: Data, payer: Uint64, serialized_transaction: Data, replace_existing: Int32) throws {
    try send_send_deferred(sender_id: sender_id, payer: payer, serialized_transaction: serialized_transaction, replace_existing: replace_existing)
    try outProtocol.transport.flush()
    try recv_send_deferred()
  }

  private func send_cancel_deferred(sender_id: Data) throws {
    try outProtocol.writeMessageBegin(name: "cancel_deferred", type: .call, sequenceID: 0)
    let args = Apply_cancel_deferred_args(sender_id: sender_id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_cancel_deferred() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_cancel_deferred_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "cancel_deferred"))
  }

  public func cancel_deferred(sender_id: Data) throws -> Int32 {
    try send_cancel_deferred(sender_id: sender_id)
    try outProtocol.transport.flush()
    return try recv_cancel_deferred()
  }

  private func send_read_transaction() throws {
    try outProtocol.writeMessageBegin(name: "read_transaction", type: .call, sequenceID: 0)
    let args = Apply_read_transaction_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_read_transaction() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_read_transaction_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "read_transaction"))
  }

  public func read_transaction() throws -> Data {
    try send_read_transaction()
    try outProtocol.transport.flush()
    return try recv_read_transaction()
  }

  private func send_transaction_size() throws {
    try outProtocol.writeMessageBegin(name: "transaction_size", type: .call, sequenceID: 0)
    let args = Apply_transaction_size_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_transaction_size() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_transaction_size_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "transaction_size"))
  }

  public func transaction_size() throws -> Int32 {
    try send_transaction_size()
    try outProtocol.transport.flush()
    return try recv_transaction_size()
  }

  private func send_tapos_block_num() throws {
    try outProtocol.writeMessageBegin(name: "tapos_block_num", type: .call, sequenceID: 0)
    let args = Apply_tapos_block_num_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_tapos_block_num() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_tapos_block_num_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "tapos_block_num"))
  }

  public func tapos_block_num() throws -> Int32 {
    try send_tapos_block_num()
    try outProtocol.transport.flush()
    return try recv_tapos_block_num()
  }

  private func send_tapos_block_prefix() throws {
    try outProtocol.writeMessageBegin(name: "tapos_block_prefix", type: .call, sequenceID: 0)
    let args = Apply_tapos_block_prefix_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_tapos_block_prefix() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_tapos_block_prefix_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "tapos_block_prefix"))
  }

  public func tapos_block_prefix() throws -> Int32 {
    try send_tapos_block_prefix()
    try outProtocol.transport.flush()
    return try recv_tapos_block_prefix()
  }

  private func send_expiration() throws {
    try outProtocol.writeMessageBegin(name: "expiration", type: .call, sequenceID: 0)
    let args = Apply_expiration_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_expiration() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_expiration_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "expiration"))
  }

  public func expiration() throws -> Int64 {
    try send_expiration()
    try outProtocol.transport.flush()
    return try recv_expiration()
  }

  private func send_get_action(_type: Int32, index: Int32) throws {
    try outProtocol.writeMessageBegin(name: "get_action", type: .call, sequenceID: 0)
    let args = Apply_get_action_args(_type: _type, index: index)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_action() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_get_action_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_action"))
  }

  public func get_action(_type: Int32, index: Int32) throws -> Data {
    try send_get_action(_type: _type, index: index)
    try outProtocol.transport.flush()
    return try recv_get_action()
  }

  private func send_get_context_free_data(index: Int32) throws {
    try outProtocol.writeMessageBegin(name: "get_context_free_data", type: .call, sequenceID: 0)
    let args = Apply_get_context_free_data_args(index: index)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_get_context_free_data() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_get_context_free_data_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "get_context_free_data"))
  }

  public func get_context_free_data(index: Int32) throws -> Data {
    try send_get_context_free_data(index: index)
    try outProtocol.transport.flush()
    return try recv_get_context_free_data()
  }

  private func send_db_store_i64(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_store_i64", type: .call, sequenceID: 0)
    let args = Apply_db_store_i64_args(scope: scope, table: table, payer: payer, id: id, data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_store_i64() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_store_i64_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_store_i64"))
  }

  public func db_store_i64(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Data) throws -> Int32 {
    try send_db_store_i64(scope: scope, table: table, payer: payer, id: id, data: data)
    try outProtocol.transport.flush()
    return try recv_db_store_i64()
  }

  private func send_db_update_i64(iterator: Int32, payer: Uint64, data: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_update_i64", type: .call, sequenceID: 0)
    let args = Apply_db_update_i64_args(iterator: iterator, payer: payer, data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_update_i64() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_update_i64_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_update_i64(iterator: Int32, payer: Uint64, data: Data) throws {
    try send_db_update_i64(iterator: iterator, payer: payer, data: data)
    try outProtocol.transport.flush()
    try recv_db_update_i64()
  }

  private func send_db_remove_i64(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_remove_i64", type: .call, sequenceID: 0)
    let args = Apply_db_remove_i64_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_remove_i64() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_remove_i64_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_remove_i64(iterator: Int32) throws {
    try send_db_remove_i64(iterator: iterator)
    try outProtocol.transport.flush()
    try recv_db_remove_i64()
  }

  private func send_db_get_i64(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_get_i64", type: .call, sequenceID: 0)
    let args = Apply_db_get_i64_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_get_i64() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_get_i64_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_get_i64"))
  }

  public func db_get_i64(iterator: Int32) throws -> Data {
    try send_db_get_i64(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_get_i64()
  }

  private func send_db_next_i64(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_next_i64", type: .call, sequenceID: 0)
    let args = Apply_db_next_i64_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_next_i64() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_next_i64_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_next_i64"))
  }

  public func db_next_i64(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_next_i64(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_next_i64()
  }

  private func send_db_previous_i64(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_previous_i64", type: .call, sequenceID: 0)
    let args = Apply_db_previous_i64_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_previous_i64() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_previous_i64_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_previous_i64"))
  }

  public func db_previous_i64(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_previous_i64(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_previous_i64()
  }

  private func send_db_find_i64(code: Uint64, scope: Uint64, table: Uint64, id: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_find_i64", type: .call, sequenceID: 0)
    let args = Apply_db_find_i64_args(code: code, scope: scope, table: table, id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_find_i64() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_find_i64_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_find_i64"))
  }

  public func db_find_i64(code: Uint64, scope: Uint64, table: Uint64, id: Uint64) throws -> Int32 {
    try send_db_find_i64(code: code, scope: scope, table: table, id: id)
    try outProtocol.transport.flush()
    return try recv_db_find_i64()
  }

  private func send_db_lowerbound_i64(code: Uint64, scope: Uint64, table: Uint64, id: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_lowerbound_i64", type: .call, sequenceID: 0)
    let args = Apply_db_lowerbound_i64_args(code: code, scope: scope, table: table, id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_lowerbound_i64() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_lowerbound_i64_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_lowerbound_i64"))
  }

  public func db_lowerbound_i64(code: Uint64, scope: Uint64, table: Uint64, id: Uint64) throws -> Int32 {
    try send_db_lowerbound_i64(code: code, scope: scope, table: table, id: id)
    try outProtocol.transport.flush()
    return try recv_db_lowerbound_i64()
  }

  private func send_db_upperbound_i64(code: Uint64, scope: Uint64, table: Uint64, id: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_upperbound_i64", type: .call, sequenceID: 0)
    let args = Apply_db_upperbound_i64_args(code: code, scope: scope, table: table, id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_upperbound_i64() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_upperbound_i64_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_upperbound_i64"))
  }

  public func db_upperbound_i64(code: Uint64, scope: Uint64, table: Uint64, id: Uint64) throws -> Int32 {
    try send_db_upperbound_i64(code: code, scope: scope, table: table, id: id)
    try outProtocol.transport.flush()
    return try recv_db_upperbound_i64()
  }

  private func send_db_end_i64(code: Uint64, scope: Uint64, table: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_end_i64", type: .call, sequenceID: 0)
    let args = Apply_db_end_i64_args(code: code, scope: scope, table: table)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_end_i64() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_end_i64_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_end_i64"))
  }

  public func db_end_i64(code: Uint64, scope: Uint64, table: Uint64) throws -> Int32 {
    try send_db_end_i64(code: code, scope: scope, table: table)
    try outProtocol.transport.flush()
    return try recv_db_end_i64()
  }

  private func send_db_idx64_store(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx64_store", type: .call, sequenceID: 0)
    let args = Apply_db_idx64_store_args(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx64_store() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx64_store_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx64_store"))
  }

  public func db_idx64_store(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Uint64) throws -> Int32 {
    try send_db_idx64_store(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
    try outProtocol.transport.flush()
    return try recv_db_idx64_store()
  }

  private func send_db_idx64_update(iterator: Int32, payer: Uint64, secondary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx64_update", type: .call, sequenceID: 0)
    let args = Apply_db_idx64_update_args(iterator: iterator, payer: payer, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx64_update() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_idx64_update_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_idx64_update(iterator: Int32, payer: Uint64, secondary: Uint64) throws {
    try send_db_idx64_update(iterator: iterator, payer: payer, secondary: secondary)
    try outProtocol.transport.flush()
    try recv_db_idx64_update()
  }

  private func send_db_idx64_remove(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx64_remove", type: .call, sequenceID: 0)
    let args = Apply_db_idx64_remove_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx64_remove() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_idx64_remove_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_idx64_remove(iterator: Int32) throws {
    try send_db_idx64_remove(iterator: iterator)
    try outProtocol.transport.flush()
    try recv_db_idx64_remove()
  }

  private func send_db_idx64_next(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx64_next", type: .call, sequenceID: 0)
    let args = Apply_db_idx64_next_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx64_next() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx64_next_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx64_next"))
  }

  public func db_idx64_next(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_idx64_next(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_idx64_next()
  }

  private func send_db_idx64_previous(iteratory: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx64_previous", type: .call, sequenceID: 0)
    let args = Apply_db_idx64_previous_args(iteratory: iteratory)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx64_previous() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx64_previous_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx64_previous"))
  }

  public func db_idx64_previous(iteratory: Int32) throws -> NextPreviousReturn {
    try send_db_idx64_previous(iteratory: iteratory)
    try outProtocol.transport.flush()
    return try recv_db_idx64_previous()
  }

  private func send_db_idx64_find_primary(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx64_find_primary", type: .call, sequenceID: 0)
    let args = Apply_db_idx64_find_primary_args(code: code, scope: scope, table: table, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx64_find_primary() throws -> FindPrimaryReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx64_find_primary_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx64_find_primary"))
  }

  public func db_idx64_find_primary(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) throws -> FindPrimaryReturn {
    try send_db_idx64_find_primary(code: code, scope: scope, table: table, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx64_find_primary()
  }

  private func send_db_idx64_find_secondary(code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx64_find_secondary", type: .call, sequenceID: 0)
    let args = Apply_db_idx64_find_secondary_args(code: code, scope: scope, table: table, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx64_find_secondary() throws -> FindSecondaryReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx64_find_secondary_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx64_find_secondary"))
  }

  public func db_idx64_find_secondary(code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64) throws -> FindSecondaryReturn {
    try send_db_idx64_find_secondary(code: code, scope: scope, table: table, secondary: secondary)
    try outProtocol.transport.flush()
    return try recv_db_idx64_find_secondary()
  }

  private func send_db_idx64_lowerbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx64_lowerbound", type: .call, sequenceID: 0)
    let args = Apply_db_idx64_lowerbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx64_lowerbound() throws -> LowerBoundUpperBoundReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx64_lowerbound_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx64_lowerbound"))
  }

  public func db_idx64_lowerbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) throws -> LowerBoundUpperBoundReturn {
    try send_db_idx64_lowerbound(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx64_lowerbound()
  }

  private func send_db_idx64_upperbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx64_upperbound", type: .call, sequenceID: 0)
    let args = Apply_db_idx64_upperbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx64_upperbound() throws -> LowerBoundUpperBoundReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx64_upperbound_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx64_upperbound"))
  }

  public func db_idx64_upperbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) throws -> LowerBoundUpperBoundReturn {
    try send_db_idx64_upperbound(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx64_upperbound()
  }

  private func send_db_idx64_end(code: Uint64, scope: Uint64, table: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx64_end", type: .call, sequenceID: 0)
    let args = Apply_db_idx64_end_args(code: code, scope: scope, table: table)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx64_end() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx64_end_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx64_end"))
  }

  public func db_idx64_end(code: Uint64, scope: Uint64, table: Uint64) throws -> Int32 {
    try send_db_idx64_end(code: code, scope: scope, table: table)
    try outProtocol.transport.flush()
    return try recv_db_idx64_end()
  }

  private func send_db_idx128_store(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx128_store", type: .call, sequenceID: 0)
    let args = Apply_db_idx128_store_args(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx128_store() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx128_store_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx128_store"))
  }

  public func db_idx128_store(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Data) throws -> Int32 {
    try send_db_idx128_store(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
    try outProtocol.transport.flush()
    return try recv_db_idx128_store()
  }

  private func send_db_idx128_update(iterator: Int32, payer: Uint64, secondary: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx128_update", type: .call, sequenceID: 0)
    let args = Apply_db_idx128_update_args(iterator: iterator, payer: payer, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx128_update() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_idx128_update_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_idx128_update(iterator: Int32, payer: Uint64, secondary: Data) throws {
    try send_db_idx128_update(iterator: iterator, payer: payer, secondary: secondary)
    try outProtocol.transport.flush()
    try recv_db_idx128_update()
  }

  private func send_db_idx128_remove(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx128_remove", type: .call, sequenceID: 0)
    let args = Apply_db_idx128_remove_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx128_remove() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_idx128_remove_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_idx128_remove(iterator: Int32) throws {
    try send_db_idx128_remove(iterator: iterator)
    try outProtocol.transport.flush()
    try recv_db_idx128_remove()
  }

  private func send_db_idx128_next(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx128_next", type: .call, sequenceID: 0)
    let args = Apply_db_idx128_next_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx128_next() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx128_next_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx128_next"))
  }

  public func db_idx128_next(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_idx128_next(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_idx128_next()
  }

  private func send_db_idx128_previous(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx128_previous", type: .call, sequenceID: 0)
    let args = Apply_db_idx128_previous_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx128_previous() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx128_previous_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx128_previous"))
  }

  public func db_idx128_previous(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_idx128_previous(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_idx128_previous()
  }

  private func send_db_idx128_find_primary(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx128_find_primary", type: .call, sequenceID: 0)
    let args = Apply_db_idx128_find_primary_args(code: code, scope: scope, table: table, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx128_find_primary() throws -> FindPrimaryReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx128_find_primary_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx128_find_primary"))
  }

  public func db_idx128_find_primary(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) throws -> FindPrimaryReturn {
    try send_db_idx128_find_primary(code: code, scope: scope, table: table, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx128_find_primary()
  }

  private func send_db_idx128_find_secondary(code: Uint64, scope: Uint64, table: Uint64, secondary: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx128_find_secondary", type: .call, sequenceID: 0)
    let args = Apply_db_idx128_find_secondary_args(code: code, scope: scope, table: table, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx128_find_secondary() throws -> FindSecondaryReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx128_find_secondary_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx128_find_secondary"))
  }

  public func db_idx128_find_secondary(code: Uint64, scope: Uint64, table: Uint64, secondary: Data) throws -> FindSecondaryReturn {
    try send_db_idx128_find_secondary(code: code, scope: scope, table: table, secondary: secondary)
    try outProtocol.transport.flush()
    return try recv_db_idx128_find_secondary()
  }

  private func send_db_idx128_lowerbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx128_lowerbound", type: .call, sequenceID: 0)
    let args = Apply_db_idx128_lowerbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx128_lowerbound() throws -> LowerBoundUpperBoundReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx128_lowerbound_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx128_lowerbound"))
  }

  public func db_idx128_lowerbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws -> LowerBoundUpperBoundReturn {
    try send_db_idx128_lowerbound(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx128_lowerbound()
  }

  private func send_db_idx128_upperbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx128_upperbound", type: .call, sequenceID: 0)
    let args = Apply_db_idx128_upperbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx128_upperbound() throws -> LowerBoundUpperBoundReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx128_upperbound_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx128_upperbound"))
  }

  public func db_idx128_upperbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws -> LowerBoundUpperBoundReturn {
    try send_db_idx128_upperbound(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx128_upperbound()
  }

  private func send_db_idx128_end(code: Uint64, scope: Uint64, table: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx128_end", type: .call, sequenceID: 0)
    let args = Apply_db_idx128_end_args(code: code, scope: scope, table: table)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx128_end() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx128_end_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx128_end"))
  }

  public func db_idx128_end(code: Uint64, scope: Uint64, table: Uint64) throws -> Int32 {
    try send_db_idx128_end(code: code, scope: scope, table: table)
    try outProtocol.transport.flush()
    return try recv_db_idx128_end()
  }

  private func send_db_idx256_store(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx256_store", type: .call, sequenceID: 0)
    let args = Apply_db_idx256_store_args(scope: scope, table: table, payer: payer, id: id, data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx256_store() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx256_store_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx256_store"))
  }

  public func db_idx256_store(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Data) throws -> Int32 {
    try send_db_idx256_store(scope: scope, table: table, payer: payer, id: id, data: data)
    try outProtocol.transport.flush()
    return try recv_db_idx256_store()
  }

  private func send_db_idx256_update(iterator: Int32, payer: Uint64, data: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx256_update", type: .call, sequenceID: 0)
    let args = Apply_db_idx256_update_args(iterator: iterator, payer: payer, data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx256_update() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_idx256_update_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_idx256_update(iterator: Int32, payer: Uint64, data: Data) throws {
    try send_db_idx256_update(iterator: iterator, payer: payer, data: data)
    try outProtocol.transport.flush()
    try recv_db_idx256_update()
  }

  private func send_db_idx256_remove(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx256_remove", type: .call, sequenceID: 0)
    let args = Apply_db_idx256_remove_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx256_remove() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_idx256_remove_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_idx256_remove(iterator: Int32) throws {
    try send_db_idx256_remove(iterator: iterator)
    try outProtocol.transport.flush()
    try recv_db_idx256_remove()
  }

  private func send_db_idx256_next(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx256_next", type: .call, sequenceID: 0)
    let args = Apply_db_idx256_next_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx256_next() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx256_next_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx256_next"))
  }

  public func db_idx256_next(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_idx256_next(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_idx256_next()
  }

  private func send_db_idx256_previous(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx256_previous", type: .call, sequenceID: 0)
    let args = Apply_db_idx256_previous_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx256_previous() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx256_previous_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx256_previous"))
  }

  public func db_idx256_previous(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_idx256_previous(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_idx256_previous()
  }

  private func send_db_idx256_find_primary(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx256_find_primary", type: .call, sequenceID: 0)
    let args = Apply_db_idx256_find_primary_args(code: code, scope: scope, table: table, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx256_find_primary() throws -> FindPrimaryReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx256_find_primary_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx256_find_primary"))
  }

  public func db_idx256_find_primary(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) throws -> FindPrimaryReturn {
    try send_db_idx256_find_primary(code: code, scope: scope, table: table, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx256_find_primary()
  }

  private func send_db_idx256_find_secondary(code: Uint64, scope: Uint64, table: Uint64, data: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx256_find_secondary", type: .call, sequenceID: 0)
    let args = Apply_db_idx256_find_secondary_args(code: code, scope: scope, table: table, data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx256_find_secondary() throws -> FindSecondaryReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx256_find_secondary_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx256_find_secondary"))
  }

  public func db_idx256_find_secondary(code: Uint64, scope: Uint64, table: Uint64, data: Data) throws -> FindSecondaryReturn {
    try send_db_idx256_find_secondary(code: code, scope: scope, table: table, data: data)
    try outProtocol.transport.flush()
    return try recv_db_idx256_find_secondary()
  }

  private func send_db_idx256_lowerbound(code: Uint64, scope: Uint64, table: Uint64, data: Data, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx256_lowerbound", type: .call, sequenceID: 0)
    let args = Apply_db_idx256_lowerbound_args(code: code, scope: scope, table: table, data: data, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx256_lowerbound() throws -> LowerBoundUpperBoundReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx256_lowerbound_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx256_lowerbound"))
  }

  public func db_idx256_lowerbound(code: Uint64, scope: Uint64, table: Uint64, data: Data, primary: Uint64) throws -> LowerBoundUpperBoundReturn {
    try send_db_idx256_lowerbound(code: code, scope: scope, table: table, data: data, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx256_lowerbound()
  }

  private func send_db_idx256_upperbound(code: Uint64, scope: Uint64, table: Uint64, data: Data, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx256_upperbound", type: .call, sequenceID: 0)
    let args = Apply_db_idx256_upperbound_args(code: code, scope: scope, table: table, data: data, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx256_upperbound() throws -> LowerBoundUpperBoundReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx256_upperbound_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx256_upperbound"))
  }

  public func db_idx256_upperbound(code: Uint64, scope: Uint64, table: Uint64, data: Data, primary: Uint64) throws -> LowerBoundUpperBoundReturn {
    try send_db_idx256_upperbound(code: code, scope: scope, table: table, data: data, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx256_upperbound()
  }

  private func send_db_idx256_end(code: Uint64, scope: Uint64, table: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx256_end", type: .call, sequenceID: 0)
    let args = Apply_db_idx256_end_args(code: code, scope: scope, table: table)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx256_end() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx256_end_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx256_end"))
  }

  public func db_idx256_end(code: Uint64, scope: Uint64, table: Uint64) throws -> Int32 {
    try send_db_idx256_end(code: code, scope: scope, table: table)
    try outProtocol.transport.flush()
    return try recv_db_idx256_end()
  }

  private func send_db_idx_double_store(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_double_store", type: .call, sequenceID: 0)
    let args = Apply_db_idx_double_store_args(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_double_store() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_double_store_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_double_store"))
  }

  public func db_idx_double_store(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Data) throws -> Int32 {
    try send_db_idx_double_store(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
    try outProtocol.transport.flush()
    return try recv_db_idx_double_store()
  }

  private func send_db_idx_double_update(iterator: Int32, payer: Uint64, secondary: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_double_update", type: .call, sequenceID: 0)
    let args = Apply_db_idx_double_update_args(iterator: iterator, payer: payer, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_double_update() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_idx_double_update_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_idx_double_update(iterator: Int32, payer: Uint64, secondary: Data) throws {
    try send_db_idx_double_update(iterator: iterator, payer: payer, secondary: secondary)
    try outProtocol.transport.flush()
    try recv_db_idx_double_update()
  }

  private func send_db_idx_double_remove(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_double_remove", type: .call, sequenceID: 0)
    let args = Apply_db_idx_double_remove_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_double_remove() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_idx_double_remove_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_idx_double_remove(iterator: Int32) throws {
    try send_db_idx_double_remove(iterator: iterator)
    try outProtocol.transport.flush()
    try recv_db_idx_double_remove()
  }

  private func send_db_idx_double_next(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_double_next", type: .call, sequenceID: 0)
    let args = Apply_db_idx_double_next_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_double_next() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_double_next_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_double_next"))
  }

  public func db_idx_double_next(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_idx_double_next(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_idx_double_next()
  }

  private func send_db_idx_double_previous(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_double_previous", type: .call, sequenceID: 0)
    let args = Apply_db_idx_double_previous_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_double_previous() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_double_previous_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_double_previous"))
  }

  public func db_idx_double_previous(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_idx_double_previous(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_idx_double_previous()
  }

  private func send_db_idx_double_find_primary(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_double_find_primary", type: .call, sequenceID: 0)
    let args = Apply_db_idx_double_find_primary_args(code: code, scope: scope, table: table, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_double_find_primary() throws -> FindPrimaryReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_double_find_primary_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_double_find_primary"))
  }

  public func db_idx_double_find_primary(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) throws -> FindPrimaryReturn {
    try send_db_idx_double_find_primary(code: code, scope: scope, table: table, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx_double_find_primary()
  }

  private func send_db_idx_double_find_secondary(code: Uint64, scope: Uint64, table: Uint64, secondary: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_double_find_secondary", type: .call, sequenceID: 0)
    let args = Apply_db_idx_double_find_secondary_args(code: code, scope: scope, table: table, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_double_find_secondary() throws -> FindSecondaryReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_double_find_secondary_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_double_find_secondary"))
  }

  public func db_idx_double_find_secondary(code: Uint64, scope: Uint64, table: Uint64, secondary: Data) throws -> FindSecondaryReturn {
    try send_db_idx_double_find_secondary(code: code, scope: scope, table: table, secondary: secondary)
    try outProtocol.transport.flush()
    return try recv_db_idx_double_find_secondary()
  }

  private func send_db_idx_double_lowerbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_double_lowerbound", type: .call, sequenceID: 0)
    let args = Apply_db_idx_double_lowerbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_double_lowerbound() throws -> LowerBoundUpperBoundReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_double_lowerbound_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_double_lowerbound"))
  }

  public func db_idx_double_lowerbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws -> LowerBoundUpperBoundReturn {
    try send_db_idx_double_lowerbound(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx_double_lowerbound()
  }

  private func send_db_idx_double_upperbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_double_upperbound", type: .call, sequenceID: 0)
    let args = Apply_db_idx_double_upperbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_double_upperbound() throws -> LowerBoundUpperBoundReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_double_upperbound_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_double_upperbound"))
  }

  public func db_idx_double_upperbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws -> LowerBoundUpperBoundReturn {
    try send_db_idx_double_upperbound(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx_double_upperbound()
  }

  private func send_db_idx_double_end(code: Uint64, scope: Uint64, table: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_double_end", type: .call, sequenceID: 0)
    let args = Apply_db_idx_double_end_args(code: code, scope: scope, table: table)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_double_end() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_double_end_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_double_end"))
  }

  public func db_idx_double_end(code: Uint64, scope: Uint64, table: Uint64) throws -> Int32 {
    try send_db_idx_double_end(code: code, scope: scope, table: table)
    try outProtocol.transport.flush()
    return try recv_db_idx_double_end()
  }

  private func send_db_idx_long_double_store(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_long_double_store", type: .call, sequenceID: 0)
    let args = Apply_db_idx_long_double_store_args(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_long_double_store() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_long_double_store_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_long_double_store"))
  }

  public func db_idx_long_double_store(scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Data) throws -> Int32 {
    try send_db_idx_long_double_store(scope: scope, table: table, payer: payer, id: id, secondary: secondary)
    try outProtocol.transport.flush()
    return try recv_db_idx_long_double_store()
  }

  private func send_db_idx_long_double_update(iterator: Int32, payer: Uint64, secondary: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_long_double_update", type: .call, sequenceID: 0)
    let args = Apply_db_idx_long_double_update_args(iterator: iterator, payer: payer, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_long_double_update() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_idx_long_double_update_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_idx_long_double_update(iterator: Int32, payer: Uint64, secondary: Data) throws {
    try send_db_idx_long_double_update(iterator: iterator, payer: payer, secondary: secondary)
    try outProtocol.transport.flush()
    try recv_db_idx_long_double_update()
  }

  private func send_db_idx_long_double_remove(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_long_double_remove", type: .call, sequenceID: 0)
    let args = Apply_db_idx_long_double_remove_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_long_double_remove() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Apply_db_idx_long_double_remove_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func db_idx_long_double_remove(iterator: Int32) throws {
    try send_db_idx_long_double_remove(iterator: iterator)
    try outProtocol.transport.flush()
    try recv_db_idx_long_double_remove()
  }

  private func send_db_idx_long_double_next(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_long_double_next", type: .call, sequenceID: 0)
    let args = Apply_db_idx_long_double_next_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_long_double_next() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_long_double_next_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_long_double_next"))
  }

  public func db_idx_long_double_next(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_idx_long_double_next(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_idx_long_double_next()
  }

  private func send_db_idx_long_double_previous(iterator: Int32) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_long_double_previous", type: .call, sequenceID: 0)
    let args = Apply_db_idx_long_double_previous_args(iterator: iterator)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_long_double_previous() throws -> NextPreviousReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_long_double_previous_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_long_double_previous"))
  }

  public func db_idx_long_double_previous(iterator: Int32) throws -> NextPreviousReturn {
    try send_db_idx_long_double_previous(iterator: iterator)
    try outProtocol.transport.flush()
    return try recv_db_idx_long_double_previous()
  }

  private func send_db_idx_long_double_find_primary(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_long_double_find_primary", type: .call, sequenceID: 0)
    let args = Apply_db_idx_long_double_find_primary_args(code: code, scope: scope, table: table, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_long_double_find_primary() throws -> FindPrimaryReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_long_double_find_primary_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_long_double_find_primary"))
  }

  public func db_idx_long_double_find_primary(code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) throws -> FindPrimaryReturn {
    try send_db_idx_long_double_find_primary(code: code, scope: scope, table: table, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx_long_double_find_primary()
  }

  private func send_db_idx_long_double_find_secondary(code: Uint64, scope: Uint64, table: Uint64, secondary: Data) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_long_double_find_secondary", type: .call, sequenceID: 0)
    let args = Apply_db_idx_long_double_find_secondary_args(code: code, scope: scope, table: table, secondary: secondary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_long_double_find_secondary() throws -> FindSecondaryReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_long_double_find_secondary_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_long_double_find_secondary"))
  }

  public func db_idx_long_double_find_secondary(code: Uint64, scope: Uint64, table: Uint64, secondary: Data) throws -> FindSecondaryReturn {
    try send_db_idx_long_double_find_secondary(code: code, scope: scope, table: table, secondary: secondary)
    try outProtocol.transport.flush()
    return try recv_db_idx_long_double_find_secondary()
  }

  private func send_db_idx_long_double_lowerbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_long_double_lowerbound", type: .call, sequenceID: 0)
    let args = Apply_db_idx_long_double_lowerbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_long_double_lowerbound() throws -> LowerBoundUpperBoundReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_long_double_lowerbound_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_long_double_lowerbound"))
  }

  public func db_idx_long_double_lowerbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws -> LowerBoundUpperBoundReturn {
    try send_db_idx_long_double_lowerbound(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx_long_double_lowerbound()
  }

  private func send_db_idx_long_double_upperbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_long_double_upperbound", type: .call, sequenceID: 0)
    let args = Apply_db_idx_long_double_upperbound_args(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_long_double_upperbound() throws -> LowerBoundUpperBoundReturn {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_long_double_upperbound_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_long_double_upperbound"))
  }

  public func db_idx_long_double_upperbound(code: Uint64, scope: Uint64, table: Uint64, secondary: Data, primary: Uint64) throws -> LowerBoundUpperBoundReturn {
    try send_db_idx_long_double_upperbound(code: code, scope: scope, table: table, secondary: secondary, primary: primary)
    try outProtocol.transport.flush()
    return try recv_db_idx_long_double_upperbound()
  }

  private func send_db_idx_long_double_end(code: Uint64, scope: Uint64, table: Uint64) throws {
    try outProtocol.writeMessageBegin(name: "db_idx_long_double_end", type: .call, sequenceID: 0)
    let args = Apply_db_idx_long_double_end_args(code: code, scope: scope, table: table)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_db_idx_long_double_end() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Apply_db_idx_long_double_end_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "db_idx_long_double_end"))
  }

  public func db_idx_long_double_end(code: Uint64, scope: Uint64, table: Uint64) throws -> Int32 {
    try send_db_idx_long_double_end(code: code, scope: scope, table: table)
    try outProtocol.transport.flush()
    return try recv_db_idx_long_double_end()
  }

}

extension ApplyProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["end_apply"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_end_apply_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_end_apply_result()
      do {
        result.success = try handler.end_apply()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "end_apply", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_active_producers"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_get_active_producers_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_get_active_producers_result()
      do {
        result.success = try handler.get_active_producers()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_active_producers", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_resource_limits"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_get_resource_limits_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_get_resource_limits_result()
      do {
        result.success = try handler.get_resource_limits(account: args.account)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_resource_limits", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["set_resource_limits"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_set_resource_limits_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_set_resource_limits_result()
      do {
        try handler.set_resource_limits(account: args.account, ram_bytes: args.ram_bytes, net_weight: args.net_weight, cpu_weight: args.cpu_weight)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "set_resource_limits", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["set_proposed_producers"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_set_proposed_producers_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_set_proposed_producers_result()
      do {
        result.success = try handler.set_proposed_producers(producer_data: args.producer_data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "set_proposed_producers", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["set_proposed_producers_ex"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_set_proposed_producers_ex_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_set_proposed_producers_ex_result()
      do {
        result.success = try handler.set_proposed_producers_ex(producer_data_format: args.producer_data_format, producer_data: args.producer_data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "set_proposed_producers_ex", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["is_privileged"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_is_privileged_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_is_privileged_result()
      do {
        result.success = try handler.is_privileged(account: args.account)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "is_privileged", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["set_privileged"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_set_privileged_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_set_privileged_result()
      do {
        try handler.set_privileged(account: args.account, is_priv: args.is_priv)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "set_privileged", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["set_blockchain_parameters_packed"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_set_blockchain_parameters_packed_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_set_blockchain_parameters_packed_result()
      do {
        try handler.set_blockchain_parameters_packed(data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "set_blockchain_parameters_packed", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_blockchain_parameters_packed"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_get_blockchain_parameters_packed_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_get_blockchain_parameters_packed_result()
      do {
        result.success = try handler.get_blockchain_parameters_packed()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_blockchain_parameters_packed", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["preactivate_feature"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_preactivate_feature_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_preactivate_feature_result()
      do {
        try handler.preactivate_feature(feature_digest: args.feature_digest)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "preactivate_feature", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["check_transaction_authorization"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_check_transaction_authorization_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_check_transaction_authorization_result()
      do {
        result.success = try handler.check_transaction_authorization(trx_data: args.trx_data, pubkeys_data: args.pubkeys_data, perms_data: args.perms_data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "check_transaction_authorization", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["check_permission_authorization"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_check_permission_authorization_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_check_permission_authorization_result()
      do {
        result.success = try handler.check_permission_authorization(account: args.account, permission: args.permission, pubkeys_data: args.pubkeys_data, perms_data: args.perms_data, delay_us: args.delay_us)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "check_permission_authorization", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_permission_last_used"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_get_permission_last_used_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_get_permission_last_used_result()
      do {
        result.success = try handler.get_permission_last_used(account: args.account, permission: args.permission)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_permission_last_used", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_account_creation_time"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_get_account_creation_time_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_get_account_creation_time_result()
      do {
        result.success = try handler.get_account_creation_time(account: args.account)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_account_creation_time", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["prints"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_prints_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_prints_result()
      do {
        try handler.prints(cstr: args.cstr)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "prints", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["prints_l"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_prints_l_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_prints_l_result()
      do {
        try handler.prints_l(cstr: args.cstr)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "prints_l", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["printi"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_printi_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_printi_result()
      do {
        try handler.printi(n: args.n)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "printi", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["printui"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_printui_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_printui_result()
      do {
        try handler.printui(n: args.n)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "printui", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["printi128"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_printi128_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_printi128_result()
      do {
        try handler.printi128(value: args.value)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "printi128", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["printui128"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_printui128_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_printui128_result()
      do {
        try handler.printui128(value: args.value)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "printui128", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["printsf"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_printsf_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_printsf_result()
      do {
        try handler.printsf(value: args.value)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "printsf", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["printdf"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_printdf_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_printdf_result()
      do {
        try handler.printdf(value: args.value)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "printdf", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["printqf"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_printqf_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_printqf_result()
      do {
        try handler.printqf(value: args.value)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "printqf", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["printn"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_printn_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_printn_result()
      do {
        try handler.printn(name: args.name)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "printn", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["printhex"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_printhex_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_printhex_result()
      do {
        try handler.printhex(data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "printhex", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["action_data_size"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_action_data_size_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_action_data_size_result()
      do {
        result.success = try handler.action_data_size()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "action_data_size", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["read_action_data"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_read_action_data_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_read_action_data_result()
      do {
        result.success = try handler.read_action_data()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "read_action_data", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["require_recipient"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_require_recipient_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_require_recipient_result()
      do {
        try handler.require_recipient(name: args.name)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "require_recipient", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["require_auth"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_require_auth_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_require_auth_result()
      do {
        try handler.require_auth(name: args.name)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "require_auth", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["has_auth"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_has_auth_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_has_auth_result()
      do {
        result.success = try handler.has_auth(name: args.name)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "has_auth", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["require_auth2"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_require_auth2_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_require_auth2_result()
      do {
        try handler.require_auth2(name: args.name, permission: args.permission)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "require_auth2", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["is_account"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_is_account_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_is_account_result()
      do {
        result.success = try handler.is_account(name: args.name)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "is_account", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["send_inline"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_send_inline_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_send_inline_result()
      do {
        try handler.send_inline(serialized_action: args.serialized_action)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "send_inline", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["send_context_free_inline"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_send_context_free_inline_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_send_context_free_inline_result()
      do {
        try handler.send_context_free_inline(serialized_data: args.serialized_data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "send_context_free_inline", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["publication_time"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_publication_time_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_publication_time_result()
      do {
        result.success = try handler.publication_time()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "publication_time", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["current_receiver"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_current_receiver_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_current_receiver_result()
      do {
        result.success = try handler.current_receiver()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "current_receiver", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["eosio_assert"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_eosio_assert_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_eosio_assert_result()
      do {
        try handler.eosio_assert(test: args.test, msg: args.msg)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "eosio_assert", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["eosio_assert_message"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_eosio_assert_message_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_eosio_assert_message_result()
      do {
        try handler.eosio_assert_message(test: args.test, msg: args.msg)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "eosio_assert_message", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["eosio_assert_code"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_eosio_assert_code_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_eosio_assert_code_result()
      do {
        try handler.eosio_assert_code(test: args.test, code: args.code)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "eosio_assert_code", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["eosio_exit"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_eosio_exit_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_eosio_exit_result()
      do {
        try handler.eosio_exit(code: args.code)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "eosio_exit", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["current_time"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_current_time_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_current_time_result()
      do {
        result.success = try handler.current_time()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "current_time", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["is_feature_activated"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_is_feature_activated_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_is_feature_activated_result()
      do {
        result.success = try handler.is_feature_activated(feature_digest: args.feature_digest)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "is_feature_activated", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_sender"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_get_sender_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_get_sender_result()
      do {
        result.success = try handler.get_sender()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_sender", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["assert_sha256"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_assert_sha256_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_assert_sha256_result()
      do {
        try handler.assert_sha256(data: args.data, hash: args.hash)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "assert_sha256", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["assert_sha1"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_assert_sha1_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_assert_sha1_result()
      do {
        try handler.assert_sha1(data: args.data, hash: args.hash)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "assert_sha1", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["assert_sha512"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_assert_sha512_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_assert_sha512_result()
      do {
        try handler.assert_sha512(data: args.data, hash: args.hash)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "assert_sha512", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["assert_ripemd160"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_assert_ripemd160_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_assert_ripemd160_result()
      do {
        try handler.assert_ripemd160(data: args.data, hash: args.hash)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "assert_ripemd160", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["sha256"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_sha256_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_sha256_result()
      do {
        result.success = try handler.sha256(data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sha256", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["sha1"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_sha1_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_sha1_result()
      do {
        result.success = try handler.sha1(data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sha1", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["sha512"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_sha512_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_sha512_result()
      do {
        result.success = try handler.sha512(data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sha512", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["ripemd160"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_ripemd160_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_ripemd160_result()
      do {
        result.success = try handler.ripemd160(data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "ripemd160", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["recover_key"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_recover_key_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_recover_key_result()
      do {
        result.success = try handler.recover_key(digest: args.digest, sig: args.sig)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "recover_key", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["assert_recover_key"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_assert_recover_key_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_assert_recover_key_result()
      do {
        try handler.assert_recover_key(digest: args.digest, sig: args.sig, pub: args.pub)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "assert_recover_key", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["send_deferred"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_send_deferred_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_send_deferred_result()
      do {
        try handler.send_deferred(sender_id: args.sender_id, payer: args.payer, serialized_transaction: args.serialized_transaction, replace_existing: args.replace_existing)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "send_deferred", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["cancel_deferred"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_cancel_deferred_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_cancel_deferred_result()
      do {
        result.success = try handler.cancel_deferred(sender_id: args.sender_id)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "cancel_deferred", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["read_transaction"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_read_transaction_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_read_transaction_result()
      do {
        result.success = try handler.read_transaction()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "read_transaction", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["transaction_size"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_transaction_size_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_transaction_size_result()
      do {
        result.success = try handler.transaction_size()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "transaction_size", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["tapos_block_num"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_tapos_block_num_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_tapos_block_num_result()
      do {
        result.success = try handler.tapos_block_num()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "tapos_block_num", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["tapos_block_prefix"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_tapos_block_prefix_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_tapos_block_prefix_result()
      do {
        result.success = try handler.tapos_block_prefix()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "tapos_block_prefix", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["expiration"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_expiration_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_expiration_result()
      do {
        result.success = try handler.expiration()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "expiration", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_action"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_get_action_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_get_action_result()
      do {
        result.success = try handler.get_action(_type: args._type, index: args.index)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_action", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["get_context_free_data"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_get_context_free_data_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_get_context_free_data_result()
      do {
        result.success = try handler.get_context_free_data(index: args.index)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "get_context_free_data", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_store_i64"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_store_i64_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_store_i64_result()
      do {
        result.success = try handler.db_store_i64(scope: args.scope, table: args.table, payer: args.payer, id: args.id, data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_store_i64", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_update_i64"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_update_i64_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_update_i64_result()
      do {
        try handler.db_update_i64(iterator: args.iterator, payer: args.payer, data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_update_i64", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_remove_i64"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_remove_i64_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_remove_i64_result()
      do {
        try handler.db_remove_i64(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_remove_i64", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_get_i64"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_get_i64_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_get_i64_result()
      do {
        result.success = try handler.db_get_i64(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_get_i64", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_next_i64"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_next_i64_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_next_i64_result()
      do {
        result.success = try handler.db_next_i64(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_next_i64", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_previous_i64"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_previous_i64_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_previous_i64_result()
      do {
        result.success = try handler.db_previous_i64(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_previous_i64", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_find_i64"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_find_i64_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_find_i64_result()
      do {
        result.success = try handler.db_find_i64(code: args.code, scope: args.scope, table: args.table, id: args.id)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_find_i64", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_lowerbound_i64"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_lowerbound_i64_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_lowerbound_i64_result()
      do {
        result.success = try handler.db_lowerbound_i64(code: args.code, scope: args.scope, table: args.table, id: args.id)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_lowerbound_i64", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_upperbound_i64"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_upperbound_i64_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_upperbound_i64_result()
      do {
        result.success = try handler.db_upperbound_i64(code: args.code, scope: args.scope, table: args.table, id: args.id)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_upperbound_i64", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_end_i64"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_end_i64_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_end_i64_result()
      do {
        result.success = try handler.db_end_i64(code: args.code, scope: args.scope, table: args.table)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_end_i64", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx64_store"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx64_store_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx64_store_result()
      do {
        result.success = try handler.db_idx64_store(scope: args.scope, table: args.table, payer: args.payer, id: args.id, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx64_store", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx64_update"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx64_update_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx64_update_result()
      do {
        try handler.db_idx64_update(iterator: args.iterator, payer: args.payer, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx64_update", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx64_remove"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx64_remove_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx64_remove_result()
      do {
        try handler.db_idx64_remove(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx64_remove", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx64_next"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx64_next_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx64_next_result()
      do {
        result.success = try handler.db_idx64_next(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx64_next", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx64_previous"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx64_previous_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx64_previous_result()
      do {
        result.success = try handler.db_idx64_previous(iteratory: args.iteratory)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx64_previous", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx64_find_primary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx64_find_primary_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx64_find_primary_result()
      do {
        result.success = try handler.db_idx64_find_primary(code: args.code, scope: args.scope, table: args.table, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx64_find_primary", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx64_find_secondary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx64_find_secondary_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx64_find_secondary_result()
      do {
        result.success = try handler.db_idx64_find_secondary(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx64_find_secondary", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx64_lowerbound"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx64_lowerbound_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx64_lowerbound_result()
      do {
        result.success = try handler.db_idx64_lowerbound(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx64_lowerbound", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx64_upperbound"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx64_upperbound_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx64_upperbound_result()
      do {
        result.success = try handler.db_idx64_upperbound(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx64_upperbound", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx64_end"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx64_end_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx64_end_result()
      do {
        result.success = try handler.db_idx64_end(code: args.code, scope: args.scope, table: args.table)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx64_end", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx128_store"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx128_store_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx128_store_result()
      do {
        result.success = try handler.db_idx128_store(scope: args.scope, table: args.table, payer: args.payer, id: args.id, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx128_store", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx128_update"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx128_update_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx128_update_result()
      do {
        try handler.db_idx128_update(iterator: args.iterator, payer: args.payer, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx128_update", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx128_remove"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx128_remove_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx128_remove_result()
      do {
        try handler.db_idx128_remove(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx128_remove", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx128_next"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx128_next_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx128_next_result()
      do {
        result.success = try handler.db_idx128_next(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx128_next", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx128_previous"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx128_previous_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx128_previous_result()
      do {
        result.success = try handler.db_idx128_previous(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx128_previous", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx128_find_primary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx128_find_primary_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx128_find_primary_result()
      do {
        result.success = try handler.db_idx128_find_primary(code: args.code, scope: args.scope, table: args.table, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx128_find_primary", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx128_find_secondary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx128_find_secondary_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx128_find_secondary_result()
      do {
        result.success = try handler.db_idx128_find_secondary(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx128_find_secondary", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx128_lowerbound"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx128_lowerbound_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx128_lowerbound_result()
      do {
        result.success = try handler.db_idx128_lowerbound(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx128_lowerbound", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx128_upperbound"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx128_upperbound_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx128_upperbound_result()
      do {
        result.success = try handler.db_idx128_upperbound(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx128_upperbound", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx128_end"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx128_end_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx128_end_result()
      do {
        result.success = try handler.db_idx128_end(code: args.code, scope: args.scope, table: args.table)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx128_end", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx256_store"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx256_store_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx256_store_result()
      do {
        result.success = try handler.db_idx256_store(scope: args.scope, table: args.table, payer: args.payer, id: args.id, data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx256_store", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx256_update"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx256_update_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx256_update_result()
      do {
        try handler.db_idx256_update(iterator: args.iterator, payer: args.payer, data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx256_update", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx256_remove"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx256_remove_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx256_remove_result()
      do {
        try handler.db_idx256_remove(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx256_remove", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx256_next"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx256_next_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx256_next_result()
      do {
        result.success = try handler.db_idx256_next(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx256_next", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx256_previous"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx256_previous_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx256_previous_result()
      do {
        result.success = try handler.db_idx256_previous(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx256_previous", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx256_find_primary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx256_find_primary_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx256_find_primary_result()
      do {
        result.success = try handler.db_idx256_find_primary(code: args.code, scope: args.scope, table: args.table, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx256_find_primary", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx256_find_secondary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx256_find_secondary_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx256_find_secondary_result()
      do {
        result.success = try handler.db_idx256_find_secondary(code: args.code, scope: args.scope, table: args.table, data: args.data)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx256_find_secondary", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx256_lowerbound"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx256_lowerbound_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx256_lowerbound_result()
      do {
        result.success = try handler.db_idx256_lowerbound(code: args.code, scope: args.scope, table: args.table, data: args.data, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx256_lowerbound", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx256_upperbound"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx256_upperbound_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx256_upperbound_result()
      do {
        result.success = try handler.db_idx256_upperbound(code: args.code, scope: args.scope, table: args.table, data: args.data, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx256_upperbound", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx256_end"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx256_end_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx256_end_result()
      do {
        result.success = try handler.db_idx256_end(code: args.code, scope: args.scope, table: args.table)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx256_end", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_double_store"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_double_store_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_double_store_result()
      do {
        result.success = try handler.db_idx_double_store(scope: args.scope, table: args.table, payer: args.payer, id: args.id, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_double_store", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_double_update"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_double_update_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_double_update_result()
      do {
        try handler.db_idx_double_update(iterator: args.iterator, payer: args.payer, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_double_update", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_double_remove"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_double_remove_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_double_remove_result()
      do {
        try handler.db_idx_double_remove(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_double_remove", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_double_next"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_double_next_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_double_next_result()
      do {
        result.success = try handler.db_idx_double_next(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_double_next", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_double_previous"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_double_previous_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_double_previous_result()
      do {
        result.success = try handler.db_idx_double_previous(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_double_previous", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_double_find_primary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_double_find_primary_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_double_find_primary_result()
      do {
        result.success = try handler.db_idx_double_find_primary(code: args.code, scope: args.scope, table: args.table, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_double_find_primary", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_double_find_secondary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_double_find_secondary_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_double_find_secondary_result()
      do {
        result.success = try handler.db_idx_double_find_secondary(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_double_find_secondary", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_double_lowerbound"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_double_lowerbound_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_double_lowerbound_result()
      do {
        result.success = try handler.db_idx_double_lowerbound(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_double_lowerbound", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_double_upperbound"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_double_upperbound_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_double_upperbound_result()
      do {
        result.success = try handler.db_idx_double_upperbound(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_double_upperbound", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_double_end"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_double_end_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_double_end_result()
      do {
        result.success = try handler.db_idx_double_end(code: args.code, scope: args.scope, table: args.table)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_double_end", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_long_double_store"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_long_double_store_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_long_double_store_result()
      do {
        result.success = try handler.db_idx_long_double_store(scope: args.scope, table: args.table, payer: args.payer, id: args.id, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_long_double_store", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_long_double_update"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_long_double_update_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_long_double_update_result()
      do {
        try handler.db_idx_long_double_update(iterator: args.iterator, payer: args.payer, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_long_double_update", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_long_double_remove"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_long_double_remove_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_long_double_remove_result()
      do {
        try handler.db_idx_long_double_remove(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_long_double_remove", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_long_double_next"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_long_double_next_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_long_double_next_result()
      do {
        result.success = try handler.db_idx_long_double_next(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_long_double_next", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_long_double_previous"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_long_double_previous_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_long_double_previous_result()
      do {
        result.success = try handler.db_idx_long_double_previous(iterator: args.iterator)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_long_double_previous", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_long_double_find_primary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_long_double_find_primary_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_long_double_find_primary_result()
      do {
        result.success = try handler.db_idx_long_double_find_primary(code: args.code, scope: args.scope, table: args.table, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_long_double_find_primary", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_long_double_find_secondary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_long_double_find_secondary_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_long_double_find_secondary_result()
      do {
        result.success = try handler.db_idx_long_double_find_secondary(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_long_double_find_secondary", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_long_double_lowerbound"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_long_double_lowerbound_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_long_double_lowerbound_result()
      do {
        result.success = try handler.db_idx_long_double_lowerbound(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_long_double_lowerbound", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_long_double_upperbound"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_long_double_upperbound_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_long_double_upperbound_result()
      do {
        result.success = try handler.db_idx_long_double_upperbound(code: args.code, scope: args.scope, table: args.table, secondary: args.secondary, primary: args.primary)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_long_double_upperbound", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["db_idx_long_double_end"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Apply_db_idx_long_double_end_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Apply_db_idx_long_double_end_result()
      do {
        result.success = try handler.db_idx_long_double_end(code: args.code, scope: args.scope, table: args.table)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "db_idx_long_double_end", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = ApplyProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

